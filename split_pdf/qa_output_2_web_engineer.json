{
  "total_qa_pairs": 168,
  "qa_pairs": [
    {
      "question": "JavaScript有哪些数据类型？",
      "answer": "JavaScript共有八种数据类型，分别是Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。"
    },
    {
      "question": "什么是Symbol数据类型？",
      "answer": "Symbol代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。"
    },
    {
      "question": "如何获取安全的undefined值？",
      "answer": "因为undefined是一个标识符，可被当作变量使用和赋值，会影响其正常判断。表达式void___没有返回值，返回结果是undefined，void并不改变表达式的结果，只是让表达式不返回值，因此可以用void0来获得undefined。"
    },
    {
      "question": "Object.is()与比较操作符“===”、“==”的区别是什么？",
      "answer": "使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较；使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回false；使用Object.is来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如-0和+0不再相等，两个NaN是相等的。"
    },
    {
      "question": "如何判断一个对象是空对象？",
      "answer": "使用JSON自带的.stringify方法来判断；使用ES6新增的方法Object.keys()来判断。"
    },
    {
      "question": "const对象的属性可以修改吗？请解释原因。",
      "answer": "const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。"
    },
    {
      "question": "new操作符的实现步骤是什么？",
      "answer": "1.创建一个对象；2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）；3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）；4.返回新的对象。"
    },
    {
      "question": "对象扩展运算符的作用是什么？",
      "answer": "对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。"
    },
    {
      "question": "JSON.stringify函数和JSON.parse函数的作用分别是什么？",
      "answer": "JSON.stringify函数，通过传入一个符合JSON格式的数据结构，将其转换为一个JSON字符串。如果传入的数据结构不符合JSON格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。JSON.parse()函数，用来将JSON格式的字符串转换为一个js数据结构，如果传入的字符串不是标准的JSON格式的字符串的话，将会抛出错误。"
    },
    {
      "question": "给js脚本添加defer属性有什么作用？",
      "answer": "这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文 件，这样的话就能使页面的渲染不被阻塞。多个设置了defer属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。"
    },
    {
      "question": "什么是DOM和BOM？",
      "answer": "DOM指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。BOM指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是window，而window对象具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象。"
    },
    {
      "question": "创建AJAX请求的步骤是什么？",
      "answer": "1. 创建一个XMLHttpRequest对象。2. 在这个对象上使用open方法创建一个HTTP请求，open方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。3. 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过setRequestHeader方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个XMLHttpRequest对象一共有5个状态，当它的状态变化时会触发onreadystatechange事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的readyState变为4的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是2xx或者304的话则代表返回正常。这个时候就可以通过response中的数据来对页面进行更新了。4. 当对象的属性和监听函数设置完成后，最后调用sent方法来向服务器发起请求，可以传入参数作为发送的数据体。"
    },
    {
      "question": "Fetch的优点有哪些？",
      "answer": "语法简洁，更加语义化；基于标准Promise实现，支持async/await；更加底层，提供的API丰富（request,response）；脱离了XHR，是ES规范里新的实现方式。"
    },
    {
      "question": "什么是原型链？",
      "answer": "当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这就是原型链的概念。原型链的尽头一般来说都是Object.prototype。"
    },
    {
      "question": "Axios有哪些特点？",
      "answer": "浏览器端发起XMLHttpRequests请求；node端发起http请求；支持Promise API；监听请求和返回；对请求和返回进行转化；取消请求；自动转换json数据；客户端支持抵御XSRF攻击。"
    },
    {
      "question": "如何在fetch中带上cookie？",
      "answer": "需要添加配置项：fetch(url, {credentials:'include'})。"
    },
    {
      "question": "this对象在函数调用模式下指向什么？",
      "answer": "当一个函数不是一个对象的属性时，直接作为函数来调用时，this指向全局对象。"
    },
    {
      "question": "call()和apply()的区别是什么？",
      "answer": "它们的作用一模一样，区别仅在于传入参数的形式的不同。apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数。"
    },
    {
      "question": "JavaScript中异步编程的实现方式有哪些？",
      "answer": "JavaScript中的异步机制可以分为以下几种：回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。Promise的方式，使用Promise的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个then的链式调用，可能会造成代码的语义不够明确。generator的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在generator内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行generator的机制，比如说co模块等方式来实现generator的自动执行。async函数的方式，async函数是generator和promise实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个await语句的时候，如果语句返回一个promise对象，那么函数将会等待promise对象的状态变为resolve后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。"
    },
    {
      "question": "Promise的实例有哪三个状态？",
      "answer": "Promise的实例有三个状态:Pending（进行中）、Resolved（已完成）、Rejected（已拒绝）。"
    },
    {
      "question": "简述对Promise的理解",
      "answer": "Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。Promise的实例有三个状态:Pending（进行中）、Resolved（已完成）、Rejected（已拒绝）。Promise的实例有两个过程：pending->fulfilled:Resolved（已完成），pending->rejected：Rejected（已拒绝）。注意：一旦从进行状态变成为其他状态就永远不能更改状态了。Promise的特点：对象的状态不受外界影响。一旦状态改变就不会再变，任何时候都可以得到这个结果。Promise的缺点：无法取消Promise，一旦新建它就会立即执行，无法中途取消。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。Promise对象是异步编程的一种解决方案，最早由社区提出。Promise是一个构造函数，接收一个函数作为参数，返回一个Promise实例。一个Promise实例有三种状态，分别是pending、resolved和rejected，分别代表了进行中、已成功和已失败。实例的状态只能由pending转变resolved或者rejected状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过resolve()和reject()函数来实现的，可以在异步操作结束后调用这两个函数改变Promise实例的状态，它的原型上定义了一个then方法，使用这个then方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。注意：在构造Promise的时候，构造函数内部的代码是立即执行的。"
    },
    {
      "question": "使用async函数时，await有什么语法要求？",
      "answer": "语法上强制规定await只能出现在asnyc函数中。"
    },
    {
      "question": "async函数没有返回值时会返回什么？",
      "answer": "它会返回Promise.resolve(undefined)。"
    },
    {
      "question": "什么是Promise.resolve(x)？",
      "answer": "Promise.resolve(x)可以看作是new Promise(resolve => resolve(x))的简写，可以用于快速封装字面量对象或其他对象，将其封装成Promise实例。"
    },
    {
      "question": "简述构造函数模式创建对象的执行过程",
      "answer": "执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的prototype属性，然后将执行上下文中的this指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。"
    },
    {
      "question": "async/await对比Promise有哪些优势？",
      "answer": "1. 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担；2. Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅；3. 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余；4. 调试友好，Promise的调试很差，由于没有代码块，不能在⼀个返回表达式的箭头函数中设置断点，在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。"
    },
    {
      "question": "组合继承的实现方式是什么？",
      "answer": "组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。"
    },
    {
      "question": "什么是原型式继承？",
      "answer": "原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5中定义的Object.create()方法就是原型式继承的实现。"
    },
    {
      "question": "哪些情况会导致内存泄漏？",
      "answer": "以下四种情况会造成内存的泄漏：意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收；被遗忘的计时器或回调函数：设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收；脱离DOM的引用：获取一个DOM元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收；闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。"
    },
    {
      "question": "Vue双向数据绑定原理的主要步骤是什么？",
      "answer": "1.需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化；2.compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图；3.Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:①在自身实例化时往属性订阅器(dep)里面添加自己②自身必须有一个update()方法③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退；4.MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。"
    },
    {
      "question": "MVC中各部分的职责是什么？",
      "answer": "MVC通过分离Model、View和Controller的方式来组织代码结构。其中View负责页面的显示逻辑，Model负责存储页面的业务数据，以及对相应数据的操作。并且View和Model应用了观察者模式，当Model层发生改变的时候它会通知有关View层更新页面。Controller层是View层和Model层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller中的事件触发器就开始工作了，通过调用Model层，来完成对Model的修改，然后Model层再去通知View层更新。"
    },
    {
      "question": "MVC模式在项目逻辑复杂时可能会出现什么问题？",
      "answer": "在MVC模式中使用观察者模式，实现Model层数据变化通知View层更新，这使得View层和Model层耦合在一起。当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。"
    },
    {
      "question": "什么是slot？",
      "answer": "slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。"
    },
    {
      "question": "简述$nextTick的实现原理",
      "answer": "Vue的nextTick其本质是对JavaScript执行原理EventLoop的一种应用。nextTick的核心是利用了如Promise、MutationObserver、setImmediate、setTimeout的原生JavaScript方法来模拟对应的微/宏任务的实现，本质是为了利用JavaScript的这些异步回调任务队列来实现Vue框架中自己的异步回调队列。"
    },
    {
      "question": "简述Vue实现数组方法实时更新的操作步骤",
      "answer": "简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ ==arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。"
    },
    {
      "question": "Vue在更新DOM时是如何执行的？",
      "answer": "Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。然后，在下一个的事件循环tick中，Vue刷新队列并执行实际（已去重的）工作。"
    },
    {
      "question": "什么是高阶组件，React和Vue在这方面有什么不同？",
      "answer": "高阶组件就是高阶函数。React可以通过高阶组件（HOC）来扩展，因为React的组件本身就是纯粹的函数，高阶函数对React来说易如反掌。而Vue.js使用HTML模板创建视图组件，模板无法有效编译，所以Vue不能采用HOC来实现，Vue需要通过mixins来扩展。"
    },
    {
      "question": "简述mixin和extends的覆盖逻辑",
      "answer": "mixin和extends均是用于合并、拓展组件的，两者均通过mergeOptions方法实现合并。mixins接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。extends主要是为了便于扩展单文件组件，接收一个对象或构造函数。"
    },
    {
      "question": "子组件可以直接改变父组件的数据吗？为什么？",
      "answer": "子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。Vue提倡单向数据流，即父级props的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug的成本会非常高。"
    },
    {
      "question": "assets和static的相同点和不同点分别是什么？",
      "answer": "相同点：assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下。不同点：assets中存放的静态资源文件在项目打包时（运行npm run build）会进行打包上传，压缩后的静态资源文件最终会放置在static文件中跟着index.html一同上传至服务器。static中放置的静态资源文件不会走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。"
    },
    {
      "question": "static中的资源文件和assets中打包后的文件相比有什么特点？",
      "answer": "static中的资源文件由于没有进行压缩等操作，文件的体积相对于assets中打包后的文件较大，在服务器中会占据更大的空间。"
    },
    {
      "question": "什么是Vue模版编译？",
      "answer": "vue中的模板template无法被浏览器解析并渲染，需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，这个转化的过程就称为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。"
    },
    {
      "question": "如何解决vue初始化页面闪动问题？",
      "answer": "首先在css里加上相关代码；如果没有彻底解决问题，则在根元素加上style=\"display: none;\":style=\"{display:'block'}\""
    },
    {
      "question": "MVVM的优点有哪些？",
      "answer": "分离视图（View）和模型（Model），降低代码耦合，提高视图或者逻辑的重用性；提高可测试性；自动更新dom，利用双向绑定，数据更新后视图自动更新，让开发者从繁琐的手动dom中解放。"
    },
    {
      "question": "v-if和v-for同时出现时如何优化？",
      "answer": "在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。"
    },
    {
      "question": "Vue实例从开始创建到卸载的一系列过程被称为什么？",
      "answer": "Vue实例从开始创建、初始化数据、编译模版、挂载Dom->渲染、更新->渲染、卸载等⼀系列过程，称这是Vue的⽣命周期。"
    },
    {
      "question": "请解释一下Vue的hash模式",
      "answer": "hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是#/vue。hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。"
    },
    {
      "question": "在Vue中，使用keep-alive包裹组件后，组件的生命周期有哪些变化？",
      "answer": "如果为一个组件包裹了keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy和destroyed就不会再被触发了，因为组件不会被真正销毁。当组件被换掉时，会被缓存到内存中、触发deactivated生命周期；当组件被切回来时，再去缓存里找这个组件、触发activated钩子函数。"
    },
    {
      "question": "简述在Vue中推荐在created钩子函数中调用异步请求的原因",
      "answer": "能更快获取到服务端数据，减少页面加载时间，用户体验更好；SSR不支持beforeMount、mounted钩子函数，放在created中有 助于一致性。"
    },
    {
      "question": "请写出Vue父子组件更新过程的执行顺序",
      "answer": "1.父组件beforeUpdate；2.子组件beforeUpdate；3.子组件updated；4.父组件updated"
    },
    {
      "question": "历史记录栈提供了什么功能？",
      "answer": "历史记录栈提供了对历史记录进行修改的功能。只是当进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。"
    },
    {
      "question": "什么是Vuex？",
      "answer": "Vuex是一个专为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store（仓库），“store”基本上就是一个容器，它包含着应用中大部分的状态(state)。"
    },
    {
      "question": "如果想要切换到history模式，需要进行什么操作？",
      "answer": "如果想要切换到history模式，就要进行以下配置（后端也要进行配置）。"
    },
    {
      "question": "调用history.pushState()相比于直接修改hash，存在哪些优势？",
      "answer": "pushState()设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，因此只能设置与当前URL同文档的URL；pushState()设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发动 作将记录添加到栈中；pushState()通过stateObject参数可以添加任意类型的数据到记录中；而hash只可添加短字符串；pushState()可额外设置title属性供后续使用。"
    },
    {
      "question": "Vuex数据流的顺序是什么？",
      "answer": "View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）"
    },
    {
      "question": "什么是Vuex的mutations？",
      "answer": "提交更改数据的方法，同步"
    },
    {
      "question": "Vuex有哪几种属性？",
      "answer": "有五种，分别是State、Getter、Mutation、Action、Module。state=>基本数据(数据源存放地)；getters=>从基本数据派生出来的数据；mutations=>提交更改数据的方法，同步；actions=>像一个装饰器，包裹mutations，使之可以异步；modules=>模块化Vuex"
    },
    {
      "question": "Vuex和单纯的全局对象有什么区别？",
      "answer": "Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会相应地得到高效更新。不能直接改变store中的状态。改变store中的状态的唯一途径就是显式地提交(commit)mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。"
    },
    {
      "question": "Vue3.0在监测机制上有什么改变？",
      "answer": "3.0将带来基于代理Proxy的observer实现，提供全语言覆盖的反应性跟踪。消除了Vue2当中基于Object.defineProperty的实现所存在的很多限制：只能监测属性，不能监测对象；检测属性的添加和删除；检测数组索引和长度的变更；支持Map、Set、WeakMap和WeakSet。"
    },
    {
      "question": "虚拟DOM的解析过程是什么？",
      "answer": "首先对将要插入到文档中的DOM树结构进行分析，使用js对象将其表示出来，比如一个元素对象，包含TagName、props和Children这些属性。然后将这个js对象树给保存下来，最后再将DOM片段插入到文档中。当页面的状态发生改变，需要对页面的DOM的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的DOM树中去，这样视图就更新了。"
    },
    {
      "question": "什么是集合类型？",
      "answer": "对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。"
    },
    {
      "question": "DIFF算法在新老虚拟DOM对比时的操作步骤是什么？",
      "answer": "首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换；如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)；比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。匹配时，找到相同的子节点，递归比较子节点。在diff中，只对同层的子节点进行比较，放弃跨级的节点比较。"
    },
    {
      "question": "Vue中v-if使用key的作用是什么？",
      "answer": "Vue中v-if使用key时，由于Vue会尽可能高效地渲染元素，通常会复用已有元素。当使用v-if实现元素切换，切换前后含有相同类型元素会被复用，若为相同input元素，用户输入不会清除，不符合需求。使用key可唯一标识一个元素，此时使用key的元素不会被复用，key的作用是用来标识一个独立的元素。"
    },
    {
      "question": "HOC的优点和缺点分别是什么？",
      "answer": "优点∶逻辑服用、不影响被包裹组件的内部逻辑。缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖。"
    },
    {
      "question": "什么是Renderprops？",
      "answer": "“renderprop”是指一种在React组件之间使用一个值为函数的prop共享代码的简单技术。具有renderprop的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，“render”的命名可以是任何其他有效的标识符。"
    },
    {
      "question": "使用Hook有哪些需要注意的地方？",
      "answer": "hook只能在组件顶层使用，不可在分支语句中使用。"
    },
    {
      "question": "React.createClass和extendsComponent在状态设置上有什么区别？",
      "answer": "React.createClass：通过getInitialState()方法返回一个包含初始值的对象；React.Component：通过constructor设置初始状态。"
    },
    {
      "question": "React中setState调用之后发生了什么？",
      "answer": "在代码中调用setState函数之后，React会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面。在React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。如果在短时间内频繁setState，React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。"
    },
    {
      "question": "在源码中，如何判断setState是先存进state队列还是直接更新？",
      "answer": "在源码中，通过isBatchingUpdates来判断setState是先存进state队列还是直接更新，如果值为true则执行异步操作，为false则直接更新。"
    },
    {
      "question": "什么是纯函数？",
      "answer": "纯函数有几个特点：给定相同的输入，总是返回相同的输出；过程没有副作用；不依赖外部状态。"
    },
    {
      "question": "React中怎么检验props？",
      "answer": "React为我们提供了PropTypes以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。如果项目中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。"
    },
    {
      "question": "请简述React废弃componentWillReceiveProps的原因",
      "answer": "在老版本的React中，如果组件自身的某个state跟其props密切相关，在componentWilReceiveProps中处理更新state会破坏state数据的单一数据源，导致组件状态不可预测，也会增加组件的重绘次数。"
    },
    {
      "question": "React16.X中props改变后在哪个生命周期中处理？",
      "answer": "在getDerivedStateFromProps中进行处理。这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。"
    },
    {
      "question": "什么是Pre-commit阶段？",
      "answer": "所谓“commit”，这里指的是“更新真正的DOM节点”这个动作。所谓Pre-commit，就是说在这个阶段其实还并没有去更新真实的DOM，不过DOM信息已经是可以读取的了。"
    },
    {
      "question": "React16中新生命周期在更新过程包含哪些函数？",
      "answer": "更新过程：getDerivedStateFromProps、shouldComponentUpdate、render、getSnapshotBeforeUpdate、componentDidUpdate。"
    },
    {
      "question": "基于hash的路由如何实现？",
      "answer": "通过监听hashchange事件，感知hash的变化。改变hash可以直接通过location.hash=xxx。"
    },
    {
      "question": "Redux主要解决什么问题？",
      "answer": "随着JavaScript单页应用开发日趋复杂，管理不断变化的state非常困难，Redux提供了一个叫store的统一仓储库，组件通过dispatch将state直接传入store，不用通过其他的组件，并且组件通过subscribe从store获取到state的改变，比组件之间互相传递数据清晰明朗。单纯的Redux只是一个状态机，react-redux作用是将Redux的状态机和React的UI呈现绑定在一起，当dispatch action改变state的时候，会自动更新页面。"
    },
    {
      "question": "Redux和Vuex的区别是什么？",
      "answer": "Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可；Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可；Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）；通俗点理解就是，vuex弱化dispatch，通过commit进行store状态的一次更变；取消了action概念，不必传入特定的action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易。"
    },
    {
      "question": "什么是概念解释型问题中Redux和Vuex的共同思想？",
      "answer": "单一的数据源，变化可以预测，本质上∶redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。"
    },
    {
      "question": "Redux中间件是如何拿到store和action并处理的？",
      "answer": "redux中间件本质就是一个函数柯里化。redux applyMiddlewareApi源码中每个middleware接受2个参数，Store的getState函数和dispatch函数，分别获得store和action，最终返回一个函数。该函数会被传入next的下一个middleware的dispatch方法，并返回一个接收action的新函数，这个函数可以直接调用next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个middleware会接受真实的store的dispatch方法作为next参数，并借此结束调用链。所以，middleware的函数签名是（{getState，dispatch})=>next=>action。"
    },
    {
      "question": "ReactHooks解决了哪些问题？",
      "answer": "（1）在组件之间复用状态逻辑很难；（2）复杂组件变得难以理解；（3）难以理解的class。"
    },
    {
      "question": "ReactHook的使用限制有哪些？",
      "answer": "不要在循环、条件或嵌套函数中调用Hook；在React的函数组件中调用Hook。"
    },
    {
      "question": "为什么不要在循环、条件或嵌套函数中调用Hook？",
      "answer": "因为Hooks的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的Hook。当然，实质上React的源码里不是数组，是链表。"
    },
    {
      "question": "什么是React diff算法？",
      "answer": "diff算法探讨的就是虚拟DOM树发生变化后，生成DOM树更新补丁的方式。它通过对比新旧两株虚拟DOM树的变更差异，将更新补丁作用于真实DOM，以最小成本完成视图更新。"
    },
    {
      "question": "简述React diff算法的具体流程",
      "answer": "1. 真实的DOM首先会映射为虚拟DOM；2. 当虚拟DOM发生变化后，就会根据差距计算生成patch，这个patch是一个结构化的数据，内容包含了增加、更新、移除等；3. 根据patch去更新真实的DOM，反馈到用户的界面上。"
    },
    {
      "question": "React diff算法总结为哪三个策略？",
      "answer": "策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）策略二：如果组件的class一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）策略三：同一层级的子节点，可以通过标记key的方式进行列表对比。（基于节点进行对比）"
    },
    {
      "question": "React key的作用是什么？",
      "answer": "Keys是React用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在ReactDiff算法中React会借助元素的Key值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React还需要借助Key值来判断元素与本地状态的关联关系。"
    },
    {
      "question": "React16.x有哪些新特性？",
      "answer": "React16.x的三大新特性TimeSlicing、Suspense、hooks。React16.8加入hooks；React16.9重命名Unsafe的生命周期方法、废弃javascript:形式的URL、废弃 \"Factory\" 组件、act（）支持异步函数、使用<React.ProfiLer>进行性能评估；React16.13.0支持在渲染期间调用setState、可检测冲突的样式规则并记录警告、废弃unstable_createPortal、将组件堆栈添加到其开发警告中。"
    },
    {
      "question": "什么是Redux中间件？",
      "answer": "Redux的中间件提供的是位于action被发起之后，到达reducer之前的扩展点，原本view->action->reducer->store的数据流加上中间件后变成了view->action->middleware->reducer->store，在这一环节可以做一些“副作用”的操作，如异步请求、打印日志等。"
    },
    {
      "question": "在React中，如何实现页面重新加载时保留数据？",
      "answer": "主要的实现方式有以下几种：Redux：将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；data.js：使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；sessionStorge：在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据；historyAPI：HistoryAPI的pushState函数可以给历史记录关联一个任意的可序列化state，所以可以在路由push的时候将当前页面的一些信息存到state中，下次返回到这个页面的时候就能从state里面取出离开前的数据重新渲染。react-router直接可以支持。这个方法适合一些需要临时存储的场景。"
    },
    {
      "question": "在React中，组件通信的方式有哪些？",
      "answer": "父组件向子组件通讯：父组件可以向子组件通过传props的方式，向子组件进行通讯；子组件向父组件通讯：props+回调的方式，父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中；兄弟组件通信：找到这两个兄弟节点共同的父节点，结合上⾯两种方式由父节点转发信息进行通信；跨层级通信：Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言，对于跨越多层的全局数据通过Context通信再适合不过；发布订阅模式：发布者发布事件，订阅者监听事件并做出反应，可以通过引入event模块进行通信。"
    },
    {
      "question": "全局状态管理工具借助什么进行通信，其原理是什么？",
      "answer": "借助Redux或者Mobx等全局状态管理工具进行通信。这种工具会维护一个全局状态中心Store，并根据不同的事件产生新的状态。"
    },
    {
      "question": "什么是懒加载？",
      "answer": "懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在长网页或应用中，若图片很多，所有图片都加载出来而用户只能看到可视窗口部分图片数据会浪费性能，使用图片懒加载在滚动屏幕之前，可视化区域之外的图片不会加载，滚动屏幕时才加载，可使网页加载速度更快，减少服务器负载。适用于图片较多，页面列表较长（长列表）的场景。"
    },
    {
      "question": "简述使用原生JavaScript实现懒加载的操作步骤。",
      "answer": "使用HTML5的data-xxx属性（这里使用data-src）来储存图片的路径，在需要加载图片的时候，将data-src中图片的路径赋值给src实现按需加载。实现重点在于确定用户需要加载哪张图片，当图片出现在可视区域时，获取图片的真实地址并赋值给图片。图片加载条件：img.offsetTop<window.innerHeight + document.body.scrollTop 。"
    },
    {
      "question": "什么是回流，哪些操作会导致回流？",
      "answer": "当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。导致回流的操作有：页面的首次渲染；浏览器的窗口大小发生变化；元素的内容发生变化；元素的尺寸或者位置发生变化；元素的字体大小发生变化；激活CSS伪类；查询某些属性或者调用某些方法；添加或者删除可见的DOM元素。"
    },
    {
      "question": "documentFragment是什么，用它跟直接操作DOM的区别是什么？",
      "answer": "DocumentFragment是文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的Document使用，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实DOM树的一部分，它的变化不会触发DOM树的重新渲染，且不会导致性能等问题。"
    },
    {
      "question": "什么是函数防抖？",
      "answer": "函数防抖是指在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。"
    },
    {
      "question": "节流函数适用于哪些场景？",
      "answer": "拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动；缩放场景：监控浏览器resize；动画场景：避免短时间内多次触发动画引起性能问题。"
    },
    {
      "question": "如何对项目中的图片进行优化？",
      "answer": "1.不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用CSS去代替。2.对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。3.小图使用base64格式。4.将多个图标文件整合到一张图片中（雪碧图）。5.选择正确的图片格式：对于能够显示WebP格式的浏览器尽量使用WebP格式。小图使用PNG，其实对于大部分图标这类图片，完全可以使用SVG代替，照片使用JPEG。"
    },
    {
      "question": "用webpack优化前端性能的方式有哪些？",
      "answer": "1. 压缩代码：删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件，利用cssnano（css-loader?minimize）来压缩css。2. 利用CDN加速：在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径。"
    },
    {
      "question": "什么是TreeShaking？",
      "answer": "将代码中永远不会⾛到的⽚段删除掉。"
    },
    {
      "question": "如何实现TreeShaking？",
      "answer": "可以通过在启动webpack时追加参数--optimize-minimize来实现。"
    },
    {
      "question": "什么是CodeSplitting？",
      "answer": "将代码按路由维度或者组件分块(chunk)，这样做到按需加载，同时可以充分利⽤浏览器缓存。"
    },
    {
      "question": "如何提取公共第三⽅库？",
      "answer": "使⽤SplitChunksPlugin插件来进⾏公共模块抽取，利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码。"
    },
    {
      "question": "Loader和Plugin在⽤法上有什么不同？",
      "answer": "Loader在module.rules中配置，作为模块的解析规则⽽存在。类型为数组，每⼀项都是⼀个Object，⾥⾯描述了对于什么类型的⽂件（test），使⽤什么加载(loader)和使⽤的参数（options）；Plugin在plugins中单独配置。类型为数组，每⼀项是⼀个plugin的实例，参数都通过构造函数传⼊。"
    },
    {
      "question": "webpack的热更新又称为什么，缩写是什么？",
      "answer": "webpack的热更新⼜称热替换（HotModuleReplacement），缩写为HMR。"
    },
    {
      "question": "请解释babel的转译过程。",
      "answer": "babel的转译过程分为三个阶段：解析Parse，将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；转换Transform，对于AST进⾏变换⼀系列的操作，babel接受得到AST并通过babel-traverse对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；⽣成Generate，将变换后的AST再转换为JS代码，使⽤到的模块是babel-generator。"
    },
    {
      "question": "简述gitpull和gitfetch的区别。",
      "answer": "gitfetch只是将远程仓库的变化下载下来，并没有和本地分支合并。gitpull会将远程仓库的变化下载下来，并和当前分支合并。"
    },
    {
      "question": "webpack热更新机制中server端和client端处理工作的第一步是什么？",
      "answer": "在webpack的watch模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack监听到⽂件变化，根据配置⽂件对模块重新编译打包，并将打包后的代码通过简单的JavaScript对象保存在内存中。"
    },
    {
      "question": "什么是XSS攻击？",
      "answer": "XSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等。XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合。"
    },
    {
      "question": "XSS攻击中攻击者可以进行哪些操作？",
      "answer": "获取页面的数据，如DOM、cookie、localStorage；DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；破坏页面结构；流量劫持（将链接指向某网站）"
    },
    {
      "question": "什么是存储型XSS？",
      "answer": "存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行"
    },
    {
      "question": "反射型XSS的攻击步骤是什么？",
      "answer": "1.攻击者构造出特殊的URL，其中包含恶意代码。2.用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器。3.用户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作"
    },
    {
      "question": "什么是CSP？",
      "answer": "CSP指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行"
    },
    {
      "question": "CSRF攻击的概念是什么？",
      "answer": "CSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作"
    },
    {
      "question": "使用origin或者referer信息验证请求的缺点是什么？",
      "answer": "有些情况下referer可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。"
    },
    {
      "question": "什么是跨站点请求伪造（CSRF）？",
      "answer": "指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。"
    },
    {
      "question": "使用CSRFToken进行验证的操作步骤是什么？",
      "answer": "服务器向用户返回一个随机数Token，当网站再次发起请求时，在请求参数中加入服务器端返回的token，然后服务器对这个token进行验证。"
    },
    {
      "question": "网络劫持分为哪几种？",
      "answer": "网络劫持分为两种：（1）DNS劫持：包括DNS强制解析（通过修改运营商的本地DNS记录，来引导用户流量到缓存服务器 ）、302跳转的方式（通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的,再对劫持的内存发起302跳转的回复，引导用户获取内容）；（2）HTTP劫持（由于http明文传输,运营商会修改你的http响应内容即加广告）。"
    },
    {
      "question": "防范HTTP劫持最有效的办法是什么？",
      "answer": "全站HTTPS，将HTTP加密，这使得运营商无法获取明文，就无法劫持你的响应内容。"
    },
    {
      "question": "定时器触发进程是什么？",
      "answer": "定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中。注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。"
    },
    {
      "question": "什么是孤儿进程和僵尸进程？",
      "answer": "孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。"
    },
    {
      "question": "如何实现浏览器内多个标签页之间的通信？",
      "answer": "实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。通信方法如下：使用websocket协议，服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。使用ShareWorker的方式，共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。使用localStorage的方式，localStorage对象就是充当的中介者的角色，在一个标签页对localStorage的变化事件进行监听，当另一个标签页修改数据时，通过这个监听事件来获取到数据。使用postMessage方法，如果能够获得对应标签页的引用，就可以使用postMessage方法进行通信。"
    },
    {
      "question": "简述浏览器缓存的全过程",
      "answer": "浏览器第一次加载资源，服务器返回200，浏览器从服务器下载资源文件，并缓存资源文件与responseheader，以供下次加载时对比使用；下一次加载资源时，先比较当前时间与上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用expires头判断是否过期；如果资源已过期，则开始协商缓存，向服务器发送带有If-None-Match和If-Modified-Since的请求；服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200。"
    },
    {
      "question": "强缓存策略通过哪两种方式设置？",
      "answer": "强缓存策略可以通过两种方式来设置，分别是http头信息中的Expires属性和Cache-Control属性。（1）服务器通过在响应头中添加Expires属性，来指定资源的过期时间。（2）在HTTP1.1中提出了Cache-Control属性，它提供了对资源的缓存的更精确的控制。"
    },
    {
      "question": "Cache-Control和Expires一起使用时，哪个优先级更高？",
      "answer": "Cache-Control的优先级要高于Expires。"
    },
    {
      "question": "什么是no-cache和no-store？",
      "answer": "no-cache是指先要和服务器确认是否有资源更新，再进行判断，即没有强缓存，但会有协商缓存；no-store是指不使用任何缓存，每次请求都直接从服务器获取资源。"
    },
    {
      "question": "简述使用Last-Modified设置协商缓存的操作步骤。",
      "answer": "服务器通过在响应头中添加Last-Modified属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个If-Modified-Since的属性，属性值为上一次资源返回时的Last-Modified的值。当请求发送到服务器后，服务器会通过这个属性来和资源的最后一次的修改时间进行比较，以此判断资源是否做了修改。如果资源没有修改，返回304状态，让客户端使用本地的缓存；如果资源已经被修改了，则返回修改后的资源。"
    },
    {
      "question": "点击刷新按钮或者按F5与按Ctrl+F5（强制刷新）有什么区别？",
      "answer": "点击刷新按钮或者按F5，浏览器直接对本地的缓存文件过期，但会带上If-Modifed-Since，If-None-Match，服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200；用户按Ctrl+F5（强制刷新），浏览器不仅会对本地文件过期，而且不会带上If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200。"
    },
    {
      "question": "Blink引擎是由哪些公司共同研发的？",
      "answer": "Blink引擎现在是谷歌公司与Opera Software共同研发。"
    },
    {
      "question": "什么是事件？",
      "answer": "事件是用户操作网页时发生的交互动作，比如click/move，事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件是用户操作网页时发生的交互动作或者网页本身的一些操作。"
    },
    {
      "question": "请简述浏览器的渲染过程。",
      "answer": "首先解析收到的文档，构建DOM树；然后解析CSS，生成CSSOM规则树；根据DOM树和CSSOM规则树构建渲染树；生成渲染树后进行布局（回流），弄清楚各个节点在页面中的确切位置和大小；最后是绘制阶段，遍历渲染树并调用渲染对象的paint方法将内容显示在屏幕上。注意，渲染引擎会尽可能早地呈现内容，并非等所有html解析完再构建和布局render树，而是解析一部分显示一部分，同时可能还在下载其余内容。"
    },
    {
      "question": "前端储存方式有哪些，各自有什么特点？",
      "answer": "cookies：在HTML5标准前本地储存的主要方式，优点是兼容性好，请求头自带cookie方便，缺点是大小只有4k，自动请求头加入cookie浪费流量，每个domain限制20个cookie，使用麻烦，需自行封装；localStorage：HTML5加入的以键值对(Key-Value)为标准的方式，优点是操作方便，永久性储存（除非手动删除），大小为5M，兼容IE8+；sessionStorage：与localStorage基本类似，区别是页面关闭后会被清理，且不能在所有同源窗口中共享，是会话级别的储存方式；WebSQL：2010年被W3C废弃的本地数据库数据存储方案，主流浏览器（火狐除外）有相关实现，类似于SQLite，是关系型数据库，用sql操作，用JavaScript时要转换，较为繁琐；IndexedDB：被正式纳入HTML5标准的数据库储存方案，是NoSQL数据库，用键值对储存，可快速读取，适合web场景，用JavaScript操作方便。"
    },
    {
      "question": "EventLoop的执行顺序是怎样的？",
      "answer": "首先执行同步代码，这属于宏任务；当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行；执行所有微任务；当执行完所有微任务后，如有必要会渲染页面；然后开始下一轮EventLoop，执行宏任务中的异步代码。"
    },
    {
      "question": "什么是幂等请求？GET和POST请求在幂等性方面有什么区别？",
      "answer": "文中未明确给出幂等请求概念解释。GET请求是一个幂等的请求，一般用于对服务器资源不会产生影响的场景；而Post不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。"
    },
    {
      "question": "如果使用浏览器原生form表单且不设置enctype属性，数据会以什么方式提交？提交的数据放在哪里，格式是怎样的？",
      "answer": "会以application/x-www-form-urlencoded方式提交数据。该种方式提交的数据放在body里面，数据按照key1=val1&key2=val2的方式进行编码，key和val都进行了URL转码。"
    },
    {
      "question": "HTTP协议和HTTPS协议的端口分别是多少？",
      "answer": "HTTP协议端口是80，HTTPS协议端口是443。"
    },
    {
      "question": "什么是HTTPS协议？",
      "answer": "超文本传输安全协议（HypertextTransferProtocolSecure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。"
    },
    {
      "question": "HTTP2的头部压缩算法是怎样的？",
      "answer": "HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。具体来说：在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。"
    },
    {
      "question": "HTTPS通信（握手）过程是什么？",
      "answer": "1.客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。2.服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。3.客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的hash的值，用来供服务器检验。4.服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的hash值来供客户端检验。5.客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。"
    },
    {
      "question": "DNS服务器解析域名的过程是什么？",
      "answer": "首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步；将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步；本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址；本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址；本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果；本地DNS服务器将返回结果保存在缓存中，便于下次使用；本地DNS服务器将返回结果返回给浏览器。"
    },
    {
      "question": "base64按功能划分工作在哪个层？",
      "answer": "base64按功能划分工作在表示层。"
    },
    {
      "question": "什么是对等通信？",
      "answer": "为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。"
    },
    {
      "question": "简述TCP三次握手的操作步骤。",
      "answer": "第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入SYN-SENT状态。第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入SYN-RECEIVED状态。第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接建立成功。"
    },
    {
      "question": "网络层的作用是什么？",
      "answer": "本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。"
    },
    {
      "question": "数据链路层的主要工作是什么？",
      "answer": "将比特组合成字节,再将字节组合成帧,使用链路层地址(以太网使用MAC地址)来访问介质,并进行差错检测。"
    },
    {
      "question": "TCP四次挥手的第一步是什么？",
      "answer": "第一次挥手：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。即客户端会发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。"
    },
    {
      "question": "什么是HTML语义化？",
      "answer": "语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。"
    },
    {
      "question": "DOCTYPE的作用是什么？",
      "answer": "DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对CSS代码甚至JavaScript脚本的解析。它必须声明在HTML文档的第一行。"
    },
    {
      "question": "script标签中没有defer或async属性时，浏览器如何处理脚本？",
      "answer": "如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。"
    },
    {
      "question": "在HTML中，蓝色、红色、绿色分别代表什么？",
      "answer": "蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。"
    },
    {
      "question": "什么是空元素？",
      "answer": "空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签。"
    },
    {
      "question": "简述浏览器在线情况下对HTML5离线储存资源的管理和加载过程。",
      "answer": "在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问页面，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。"
    },
    {
      "question": "SVG的特点有哪些？",
      "answer": "不依赖分辨率；支持事件处理器；最适合带有大型渲染区域的应用程序（比如谷歌地图）；复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）；不适合游戏应用。"
    },
    {
      "question": "简述display的inline属性特点。",
      "answer": "元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin。"
    },
    {
      "question": "CSSSprites在维护方面有哪些麻烦？",
      "answer": "页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。"
    },
    {
      "question": "什么是关键选择器？",
      "answer": "选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。"
    },
    {
      "question": "请简述CSS优化在加载性能方面的操作步骤。",
      "answer": "（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。（2）css单一样式：当需要下边距和左边距的时候，使用margin-bottom:bottom;margin-left:left;执行效率会更高。（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。"
    },
    {
      "question": "CSS工程化是为了解决哪些问题？",
      "answer": "1.宏观设计：CSS代码如何组织、如何拆分、模块结构怎样设计？2.编码优化：怎样写出更好的CSS？3.构建：如何处理我的CSS，才能让它的打包结果最优？4.可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？"
    },
    {
      "question": "预处理器出现是为了解决什么问题？",
      "answer": "随着前端业务复杂度的提高，前端工程中对CSS提出了以下诉求：1.宏观设计上：希望能优化CSS文件的目录结构，对现有的CSS文件实现复用；2.编码优化上：希望能写出结构清晰、简明易懂的CSS，需要它具有一目了然的嵌套层级关系，具有变量特征、计算能力、循环能力等更强的可编程性，少写一些无用的代码；3.可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，带来更强的可维护性。这三点是传统CSS所做不到的，也是预处理器所解决的问题。"
    },
    {
      "question": "预处理器普遍具备哪些特性？",
      "answer": "嵌套代码的能力，通过嵌套来反映不同css属性之间的层级关系；支持定义css变量；提供计算函数；允许对代码片段进行extend和mixin；支持循环语句的使用；支持将CSS文件模块化，实现复用。"
    },
    {
      "question": "什么是PostCss？",
      "answer": "PostCss仍然是一个对CSS进行解析和处理的工具，它和预处理器的不同就在于，预处理器处理的是类CSS，而PostCss处理的就是CSS本身。它可以编译尚未被浏览器广泛支持的先进的CSS语法，还可以自动为一些需要额外兼容的语法增加前缀，且有着强大的插件机制，支持各种各样的扩展，极大地强化了CSS的能力。"
    },
    {
      "question": "如何用Webpack实现对CSS的处理？",
      "answer": "Webpack在loader的辅助下可以处理CSS。Webpack中操作CSS需要使用的两个关键的loader：css-loader和style-loader。css-loader：导入CSS模块，对CSS代码进行编译处理；style-loader：创建style标签，把CSS内容写入标签。在实际使用中，css-loader的执行顺序一定要安排在style-loader的前面。"
    },
    {
      "question": "常见的CSS布局单位有哪些？",
      "answer": "常用的布局单位包括像素（px），百分比（%），em，rem，vw/vh。"
    },
    {
      "question": "如何利用绝对定位实现元素水平垂直居中（适用于盒子有宽高的情况）？",
      "answer": "利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。"
    },
    {
      "question": "什么是BFC？",
      "answer": "可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。"
    },
    {
      "question": "创建BFC的条件有哪些？",
      "answer": "根元素：body；元素设置浮动：float除none以外的值；元素设置绝对定位：position(absolute、fixed)；display值为：inline-block、table-cell、table-caption、flex等；overflow值为：hidden、auto、scroll。"
    },
    {
      "question": "如何解决1px问题（思路二）？",
      "answer": "伪元素先放大后缩小。思路是先放大、后缩小：在目标元素的后面追加一个::after伪元素，让这个元素布局为absolute之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为1px。接着借助CSS动画特效中的放缩能力，把整个伪元素缩小为原来的50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而border也缩小为了1px的二分之一，间接地实现了0.5px的效果。"
    }
  ]
}