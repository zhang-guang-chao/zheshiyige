{
  "filename": "web_eight.pdf",
  "total_pages": 182,
  "full_text": "1JavaScript部分\n1.JavaScript有哪些数据类型，它们的区别？\nJavaScript共有八种数据类型，分别是Undefined、Null、Boolean、\nNumber、String、Object、Symbol、BigInt。\n其中Symbol和BigInt是ES6中新增的数据类型：\n●Symbol代表创建后独一无二且不可变的数据类型，它主要是为了\n解决可能出现的全局变量冲突的问题。\n●BigInt是一种数字类型的数据，它可以表示任意精度格式的整数，\n使用BigInt可以安全地存储和操作大整数，即使这个数已经超出了\nNumber能够表示的安全整数范围。\n这些数据可以分为原始数据类型和引用数据类型：\n●栈：原始数据类型（Undefined、Null、Boolean、Number、String）\n●堆：引用数据类型（对象、数组和函数）\n两种类型的区别在于存储位置的不同：\n●原始数据类型直接存储在栈（stack）中的简单数据段，占据空间\n小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n●引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固\n定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈\n中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引\n用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n●在数据结构中，栈中数据的存取方式为先进后出。\n●堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大\n小来规定。\n在操作系统中，内存被分为栈区和堆区：\n2●栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的\n值等。其操作方式类似于数据结构中的栈。\n●堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可\n能由垃圾回收机制回收。\n2.数据类型检测的方式有哪些\n（1）typeof\n其中数组、对象、null都会被判断为object，其他判断都正确。\n（2）instanceof\ninstanceof可以正确判断对象的类型，其内部运行机制是判断在其\n原型链中能否找到该类型的原型。\n可以看到，instanceof只能正确判断引用数据类型，而不能判断基\n本数据类型。instanceof运算符可以用来测试一个对象在其原型链\n中是否存在一个构造函数的prototype属性。\n（3）constructor\n3\nconstructor有两个作用，一是判断数据的类型，二是对象实例通过\nconstrcutor对象访问它的构造函数。需要注意，如果创建一个对象\n来改变它的原型，constructor就不能用来判断数据类型了：\n（4）Object.prototype.toString.call()\nObject.prototype.toString.call()使用Object对象的原型方法\ntoString来判断数据类型：\n同样是检测对象obj调用toString方法，obj.toString()的结果和\nObject.prototype.toString.call(obj)的结果不一样，这是为什\n么？\n这是因为toString是Object的原型方法，而Array、function等类\n型作为Object的实例，都重写了toString方法。不同的对象类型调\n用toString方法时，根据原型链的知识，调用的是对应的重写之后\n4的toString方法（function类型返回内容为函数体的字符串，Array\n类型返回元素组成的字符串…），而不会去调用Object上原型\ntoString方法（返回对象的具体类型），所以采用obj.toString()\n不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要\n得到对象的具体类型时，应该调用Object原型上的toString方法。\n3.null和undefined区别\n首先Undefined和Null都是基本数据类型，这两个基本数据类型\n分别都只有一个值，就是undefined和null。\nundefined代表的含义是未定义，null代表的含义是空对象。一般\n变量声明了但还没有定义的时候会返回undefined，null主要用于\n赋值给一些可能会返回对象的变量，作为初始化。\nundefined在JavaScript中不是一个保留字，这意味着可以使用\nundefined来作为一个变量名，但是这样的做法是非常危险的，它会\n影响对undefined值的判断。我们可以通过一些方法获得安全的\nundefined值，比如说void0。\n当对这两种类型使用typeof进行判断时，Null类型化会返回\n“object”，这是一个历史遗留的问题。当使用双等号对两种类型的\n值进行比较时会返回true，使用三个等号时会返回false。\n4.intanceof操作符的实现原理及实现\ninstanceof运算符用于判断构造函数的prototype属性是否出现\n在对象的原型链中的任何位置。\n5\n5.如何获取安全的undefined值？\n因为undefined是一个标识符，所以可以被当作变量来使用和赋值，\n但是这样会影响undefined的正常判断。表达式void___没有返\n回值，因此返回结果是undefined。void并不改变表达式的结果，\n只是让表达式不返回值。因此可以用void0来获得undefined。\n6.Object.is()与比较操作符“===”、“==”的区别？\n使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进\n行强制类型转化后再进行比较。\n使用三等号（===）进行相等判断时，如果两边的类型不一致时，不\n会做强制类型准换，直接返回false。\n使用Object.is来进行相等判断时，一般情况下和三等号的判断相\n同，它处理了一些特殊的情况，比如-0和+0不再相等，两个NaN\n是相等的。\n7.什么是JavaScript中的包装类型？\n在JavaScript中，基本类型是没有属性和方法的，但是为了便于操\n作基本类型的值，在调用基本类型的属性或方法时JavaScript会在\n后台隐式地将基本类型的值转换为对象，如：\n6\n在访问'abc'.length时，JavaScript将'abc'在后台转换成\nString('abc')，然后再访问其length属性。\nJavaScript也可以使用Object函数显式地将基本类型转换为包装类\n型：\n也可以使用valueOf方法将包装类型倒转成基本类型：\n看看如下代码会打印出什么：\n答案是什么都不会打印，因为虽然包裹的基本类型是false，但是\nfalse被包裹成包装类型后就成了对象，所以其非值为false，所以\n循环体中的内容不会运行。\n8.为什么会有BigInt的提案？\nJavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算\n结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩\n数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，\n这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提\n出了BigInt来解决此问题。\n79.如何判断一个对象是空对象\n使用JSON自带的.stringify方法来判断：\n使用ES6新增的方法Object.keys()来判断：\n10.const对象的属性可以修改吗\nconst保证的并不是变量的值不能改动，而是变量指向的那个内存地\n址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值\n就保存在变量指向的那个内存地址，因此等同于常量。\n但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的\n内存地址，保存的只是一个指针，const只能保证这个指针是固定不\n变的，至于它指向的数据结构是不是可变的，就完全不能控制了。\n11.如果new一个箭头函数的会怎么样\n箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this\n指向，更不可以使用arguments参数，所以不能New一个箭头函数。\nnew操作符的实现步骤如下：\n1.创建一个对象\n2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性\n指向构造函数的prototype属性）\n83.指向构造函数中的代码，构造函数中的this指向该对象（也就是\n为这个对象添加属性和方法）\n4.返回新的对象\n所以，上面的第二、三步，箭头函数都是没有办法执行的。\n12.箭头函数的this指向哪⾥？\n箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃\n⼰的this，它所谓的this是捕获其所在上下⽂的this值，作为⾃\n⼰的this值，并且由于没有属于⾃⼰的this，所以是不会被new\n调⽤的，这个所谓的this也不会被改变。\n可以⽤Babel理解⼀下箭头函数:\n转化后：\n13.扩展运算符的作用及使用场景\n（1）对象扩展运算符\n对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷\n贝到当前对象之中。\n9\n上述方法实际上等价于:\nObject.assign方法用于对象的合并，将源对象（source）的所有可\n枚举属性，复制到目标对象（target）。Object.assign方法的第一\n个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对\n象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面\n的属性)。\n同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符\n内部的同名属性会被覆盖掉。\n利用上述特性就可以很方便的修改对象的部分属性。在redux中的\nreducer函数规定必须是一个纯函数，reducer中的state对象要求\n不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，\n然后产生一个新的对象返回。\n需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。\n（2）数组扩展运算符\n数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每\n次只能展开一层数组。\n下面是数组的扩展运算符的应用：\n10将数组转换为参数序列\n复制数组\n要记住：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷\n贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都\n是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。\n合并数组\n如果想在数组内合并数组，可以这样：\n扩展运算符与解构赋值结合起来，用于生成数组\n需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一\n位，否则会报错。\n将字符串转为真正的数组\n任何Iterator接口的对象，都可以用扩展运算符转为真正的数组\n11比较常见的应用是可以将某些数据结构转为数组：\n用于替换es5中的Array.prototype.slice.call(arguments)写法。\n使用Math函数获取数组中特定的值\n14.Proxy可以实现什么功能？\n在Vue3.0中通过Proxy来替换原本的Object.defineProperty\n来实现数据响应式。\nProxy是ES6中新增的功能，它可以用来自定义对象中的操作。\n代表需要添加代理的对象，handler用来自定义对象中的操作，比如\n可以用来自定义set或者get函数。\n下面来通过Proxy来实现一个数据响应式：\n12在上述代码中，通过自定义set和get函数的方式，在原本的逻辑\n中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出\n通知。\n当然这是简单版的响应式实现，如果需要实现一个Vue中的响应式，\n需要在get中收集依赖，在set派发更新，之所以Vue3.0要使用\nProxy替换原本的API原因在于Proxy无需一层层递归为每个属\n性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现\n有一些数据更新不能监听到，但是Proxy可以完美监听到任何方式\n的数据改变，唯一缺陷就是浏览器的兼容性不好。\n15.常用的正则表达式有哪些？\n16.对JSON的理解\nJSON是一种基于文本的轻量级的数据交换格式。它可以被任何的编\n程语言读取和作为数据格式来传递。\n在项目开发中，使用JSON作为前后端数据交换的方式。在前端通过\n将一个符合JSON格式的数据结构序列化为\nJSON字符串，然后将它传递到后端，后端通过JSON格式的字符串\n解析后生成对应的数据结构，以此来实现前后端数据的一个传递。\n13因为JSON的语法是基于js的，因此很容易将JSON和js中的对\n象弄混，但是应该注意的是JSON和js中的对象不是一回事，JSON\n中对象格式更加严格，比如说在JSON中属性值不能为函数，不能出\n现NaN这样的属性值等，因此大多数的js对象是不符合JSON对\n象的格式的。\n在js中提供了两个函数来实现js数据结构和JSON格式的转换\n处理，\nJSON.stringify函数，通过传入一个符合JSON格式的数据结构，\n将其转换为一个JSON字符串。如果传入的数据结构不符合JSON格\n式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合\n规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化\n为JSON格式的字符串。\nJSON.parse()函数，这个函数用来将JSON格式的字符串转换为一\n个js数据结构，如果传入的字符串不是标准的JSON格式的字符串\n的话，将会抛出错误。当从后端接收到JSON格式的字符串时，可以\n通过这个方法来将其解析为一个js数据结构，以此来进行数据的访\n问。\n17.JavaScript脚本延迟加载的方式有哪些？\n延迟加载就是等页面加载完成之后再加载JavaScript文件。js延\n迟加载有助于提高页面加载速度。\n一般有以下几种方式：\ndefer属性：给js脚本添加defer属性，这个属性会让脚本的加\n载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文\n件，这样的话就能使页面的渲染不被阻塞。多个设置了defer属性\n14的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是\n这样。\nasync属性：给js脚本添加async属性，这个属性会使脚本异步\n加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行js\n脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个async\n属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次\n执行。\n动态创建DOM方式：动态创建DOM标签的方式，可以对文档的加载\n事件进行监听，当文档加载完成后再动态的创建script标签来引入\njs脚本。\n使用setTimeout延迟方法：设置一个定时器来延迟加载js脚本文\n件\n让JS最后加载：将js脚本放在文档的底部，来使js脚本尽可能\n的在最后来加载执行。\n18.什么是DOM和BOM？\nDOM指的是文档对象模型，它指的是把文档当做一个对象，这个对象\n主要定义了处理网页内容的方法和接口。\nBOM指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，\n这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是\nwindow，而window对象具有双重角色，它既是通过js访问浏览器\n窗口的一个接口，又是一个Global（全局）对象。这意味着在网页\n中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方\n法存在。window对象含有location对象、navigator对象、screen\n15对象等子对象，并且DOM的最根本的对象document对象也是BOM\n的window对象的子对象。\n19.escape、encodeURI、encodeURIComponent的区别\nencodeURI是对整个URI进行转义，将URI中的非法字符转换为合\n法字符，所以对于一些在URI中有特殊意义的字符不会进行转义。\nencodeURIComponent是对URI的组成部分进行转义，所以一些特殊\n字符也会得到转义。\nescape和encodeURI的作用相同，不过它们对于unicode编码为\n0xff之外字符的时候会有区别，escape是直接在字符的unicode\n编码前加上%u，而encodeURI首先会将字符转换为UTF-8的格式，\n再在每个字节前加上%。\n20.对AJAX的理解，实现一个AJAX请求\nAJAX是AsynchronousJavaScriptandXML的缩写，指的是通过\nJavaScript的异步通信，从服务器获取XML文档从中提取数据，\n再更新当前网页的对应部分，而不用刷新整个网页。\n创建AJAX请求的步骤：\n创建一个XMLHttpRequest对象。\n在这个对象上使用open方法创建一个HTTP请求，open方法所需\n要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\n在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可\n以通过setRequestHeader方法来为请求添加头信息。还可以为这个\n对象添加一个状态监听函数。一个XMLHttpRequest对象一共有5\n个状态，当它的状态变化时会触发onreadystatechange事件，可以\n16通过设置监听函数，来处理请求成功后的结果。当对象的readyState\n变为4的时候，代表服务器返回的数据接收完成，这个时候可以通\n过判断请求的状态，如果状态是2xx或者304的话则代表返回正常。\n这个时候就可以通过response中的数据来对页面进行更新了。\n当对象的属性和监听函数设置完成后，最后调用sent方法来向服务\n器发起请求，可以传入参数作为发送的数据体。\n使用Promise封装AJAX：\n1721.什么是尾调用，使用尾调用有什么好处？\n尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行\n栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上\n下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，\n因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上\n下文，从而节省了内存，这就是尾调用优化。但是ES6的尾调用优\n化只在严格模式下开启，正常模式是无效的。\n22.ES6模块与CommonJS模块有什么异同？\nES6Module和CommonJS模块的区别：\nCommonJS是对模块的浅拷⻉，ES6Module是对模块的引⽤，即ES6\nModule只存只读，不能改变其值，也就是指针指向不能变，类似const；\nimport的接⼝是read-only（只读状态），不能修改其变量值。即\n不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对\ncommonJS对重新赋值（改变指针指向），但是对ES6Module赋值会\n编译报错。\nES6Module和CommonJS模块的共同点：\nCommonJS和ES6Module都可以对引⼊的对象进⾏赋值，即对对象内\n部属性的值进⾏改变。\n23.for...in和for...of的区别\nfor…of是ES6新增的遍历方式，允许遍历一个含有iterator接口\n的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…\nin的区别如下\nfor…of遍历获取的是对象的键值，for…in获取的是对象的键名；\n18for…in会遍历对象的整个原型链，性能非常差不推荐使用，而\nfor…of只遍历当前对象不会遍历原型链；\n对于数组的遍历，for…in会返回数组中所有可枚举的属性(包括原\n型链上可枚举的属性)，for…of只返回数组的下标对应的属性值；\n总结：for...in循环主要是为了遍历对象而生，不适用于遍历数组；\nfor...of循环可以用来遍历数组、类数组对象，字符串、Set、Map以\n及Generator对象。\n24.ajax、axios、fetch的区别\n（1）AJAX\nAjax即“AsynchronousJavascriptAndXML”（异步JavaScript和\nXML），是指一种创建交互式网页应用的网页开发技术。它是一种在\n无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在\n后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。\n这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行\n更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整\n个网页页面。其缺点如下：\n本身是针对MVC编程，不符合前端MVVM的浪潮\n基于原生XHR开发，XHR本身的架构不清晰\n不符合关注分离（SeparationofConcerns）的原则\n配置和调用方式非常混乱，而且基于事件的异步模型不友好。\n（2）Fetch\nfetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的\npromise对象。Fetch是基于promise设计的。Fetch的代码结构比\n19起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有\n使用XMLHttpRequest对象。\nfetch的优点：\n语法简洁，更加语义化\n基于标准Promise实现，支持async/await\n更加底层，提供的API丰富（request,response）\n脱离了XHR，是ES规范里新的实现方式\nfetch的缺点：\nfetch只对网络请求报错，对400，500都当做成功的请求，服务器\n返回400，500错误码时并不会reject，只有网络错误这些导致请\n求不能完成时，fetch才会被reject。\nfetch默认不会带cookie，需要添加配置项：fetch(url,\n{credentials:'include'})\nfetch不支持abort，不支持超时控制，使用setTimeout及\nPromise.reject的实现的超时控制并不能阻止请求过程继续在后台\n运行，造成了流量的浪费\nfetch没有办法原生监测请求的进度，而XHR可以\n（3）Axios\nAxios是一种基于Promise封装的HTTP客户端，其特点如下：\n浏览器端发起XMLHttpRequests请求\nnode端发起http请求\n支持PromiseAPI\n20监听请求和返回\n对请求和返回进行转化\n取消请求\n自动转换json数据\n客户端支持抵御XSRF攻击\n25.对原型、原型链的理解\n在JavaScript中是使用构造函数来新建一个对象的，每一个构造函\n数的内部都有一个prototype属性，它的属性值是一个对象，这个\n对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用\n构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个\n指针指向构造函数的prototype属性对应的值，在ES5中这个指针\n被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在\n浏览器中都实现了__proto__属性来访问这个属性，但是最好不要\n使用这个属性，因为它不是规范中规定的。ES5中新增了一个\nObject.getPrototypeOf()方法，可以通过这个方法来获取对象的原\n型。\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么\n它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原\n型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一\n般来说都是Object.prototype所以这就是新建的对象为什么能够\n使用toString()等方法的原因。\n特点：JavaScript对象是通过引用来传递的，创建的每个新对象实\n体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对\n象也会继承这一改变。\n21\n26.原型链的终点是什么？如何打印出原型链的终点？\n22由于Object是构造函数，原型链终点Object.prototype.__proto__，\n而Object.prototype.__proto__===null//true，所以，原型链\n的终点是null。原型链上的所有原型都是对象，所有的对象最终都\n是由Object构造的，而Object.prototype的下一级是\nObject.prototype.__proto__。\n27.对作用域、作用域链的理解\n1）全局作用域和函数作用域\n（1）全局作用域\n最外层函数和最外层函数外面定义的变量拥有全局作用域\n所有未定义直接赋值的变量自动声明为全局作用域\n所有window对象的属性拥有全局作用域\n全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空\n间，容易引起命名冲突。\n（2）函数作用域\n函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访\n问到\n作用域是分层的，内层作用域可以访问外层作用域，反之不行\n2）块级作用域\n23使用ES6中新增的let和const指令可以声明块级作用域，块级作用\n域可以在函数中创建也可以在一个代码块中的创建（由{}包裹的代\n码片段）\nlet和const声明的变量不会有变量提升，也不可以重复声明\n在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量\n限制在循环内部。\n作用域链：\n在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个\n变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域\n查找，依次向上级作用域查找，直到访问到window对象就被终止，\n这一层层的关系就是作用域链。\n作用域链的作用是保证对执行环境有权访问的所有变量和函数的有\n序访问，通过作用域链，可以访问到外层环境的变量和函数。\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个\n包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是\n当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全\n局对象）始终是作用域链的最后一个对象。\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域\n链向后查找。\n28.对this对象的理解\nthis是执行上下文中的一个属性，它指向最后一次调用这个方法的\n对象。在实际开发中，this的指向可以通过四种调用模式来判断。\n24第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作\n为函数来调用时，this指向全局对象。\n第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，\nthis指向这个对象。\n第三种是构造器调用模式，如果一个函数用new调用时，函数执行\n前会新创建一个对象，this指向这个新创建的对象。\n第四种是apply、call和bind调用模式，这三个方法都可以显\n示的指定调用函数的this指向。其中apply方法接收两个参数：\n一个是this绑定的对象，一个是参数数组。call方法接收的参数，\n第一个是this绑定的对象，后面的其余参数是传入函数执行的参数。\n也就是说，在使用call()方法时，传递给函数的参数必须逐个列举\n出来。bind方法通过传入一个对象，返回一个this绑定了传入对\n象的新函数。这个函数的this指向除了使用new时会被改变，其\n他情况下都不会改变。\n这四种方式，使用构造器调用模式的优先级最高，然后是apply、call\n和bind调用模式，然后是方法调用模式，然后是函数调用模式。\n29.call()和apply()的区别？\n它们的作用一模一样，区别仅在于传入参数的形式的不同。\napply接受两个参数，第一个参数指定了函数体内this对象的指向，\n第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类\n数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。\ncall传入的参数数量不固定，跟apply相同的是，第一个参数也是\n代表函数体内的this指向，从第二个参数开始往后，每个参数被依\n次传入函数。\n2530.异步编程的实现方式？\nJavaScript中的异步机制可以分为以下几种：\n回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函\n数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦\n合度太高，不利于代码的可维护。\nPromise的方式，使用Promise的方式可以将嵌套的回调函数作为\n链式调用。但是使用这种方法，有时会造成多个then的链式调用，\n可能会造成代码的语义不够明确。\ngenerator的方式，它可以在函数的执行过程中，将函数的执行权转\n移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行\n的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权\n给转移回来。因此在generator内部对于异步操作的方式，可以以\n同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控\n制权转移回来，因此需要有一个自动执行generator的机制，比如\n说co模块等方式来实现generator的自动执行。\nasync函数的方式，async函数是generator和promise实现的\n一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个\nawait语句的时候，如果语句返回一个promise对象，那么函数将\n会等待promise对象的状态变为resolve后再继续向下执行。因此\n可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动\n执行。\n31.对Promise的理解\n26Promise是异步编程的一种解决方案，它是一个对象，可以获取异步\n操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，\n它比传统的解决方案回调函数和事件更合理和更强大。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束\n的事件（通常是一个异步操作）的结果。从语法上说，Promise是一\n个对象，从它可以获取异步操作的消息。Promise提供统一的API，\n各种异步操作都可以用同样的方法进行处理。\n（1）Promise的实例有三个状态:\nPending（进行中）\nResolved（已完成）\nRejected（已拒绝）\n当把一件事情交给promise时，它的状态就是Pending，任务完成了\n状态就变成了Resolved、没有完成失败了就变成了Rejected。\n（2）Promise的实例有两个过程：\npending->fulfilled:Resolved（已完成）\npending->rejected：Rejected（已拒绝）\n注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\nPromise的特点：\n对象的状态不受外界影响。promise对象代表一个异步操作，有三种\n状态，pending（进行中）、fulfilled（已成功）、rejected（已失\n败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他\n操作都无法改变这个状态，这也是promise这个名字的由来——“承\n诺”；\n27一旦状态改变就不会再变，任何时候都可以得到这个结果。promise\n对象的状态改变，只有两种可能：从pending变为fulfilled，从\npending变为rejected。这时就称为resolved（已定型）。如果改\n变已经发生了，你再对promise对象添加回调函数，也会立即得到这\n个结果。这与事件（event）完全不同，事件的特点是：如果你错过\n了它，再去监听是得不到结果的。\nPromise的缺点：\n无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始\n还是即将完成）。\n总结：\nPromise对象是异步编程的一种解决方案，最早由社区提出。Promise\n是一个构造函数，接收一个函数作为参数，返回一个Promise实例。\n一个Promise实例有三种状态，分别是pending、resolved和\nrejected，分别代表了进行中、已成功和已失败。实例的状态只能由\npending转变resolved或者rejected状态，并且状态一经改变，\n就凝固了，无法再被改变了。\n状态的改变是通过resolve()和reject()函数来实现的，可以在\n异步操作结束后调用这两个函数改变Promise实例的状态，它的原\n型上定义了一个then方法，使用这个then方法可以为两个状态的\n改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的\n末尾执行。\n注意：在构造Promise的时候，构造函数内部的代码是立即执行的\n2832.Promise解决了什么问题\n在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求\n后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代\n码：\n上面的代码有如下缺点：\n后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致\n多个ajax请求嵌套的情况，代码不够直观。\n如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要\n前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上\n编写代码，导致代码不够直观。\nPromise出现之后，代码变成这样：\n这样代码看起了就简洁了很多，解决了地狱回调的问题。\n2933.对async/await的理解\nasync/await其实是Generator的语法糖，它能实现的效果都能用\nthen链来实现，它是为优化then链而开发出来的。从字面上来看，\nasync是“异步”的简写，await则为等待，所以很好理解async用\n于申明一个function是异步的，而await用于等待一个异步方法\n执行完成。当然语法上强制规定await只能出现在asnyc函数中，先\n来看看async函数返回了什么：\n所以，async函数返回的是一个Promise对象。async函数（包含\n函数语句、函数表达式、Lambda表达式）会返回一个Promise对象，\n如果在函数中return一个直接量，async会把这个直接量通过\nPromise.resolve()封装成Promise对象。\nasync函数返回的是一个Promise对象，所以在最外层不能用\nawait获取其返回值的情况下，当然应该用原来的方式：then()链\n来处理这个Promise对象，就像这样：\n30\n那如果async函数没有返回值，又该如何？很容易想到，它会返回\nPromise.resolve(undefined)。\n联想一下Promise的特点——无等待，所以在没有await的情况下\n执行async函数，它会立即执行，返回一个Promise对象，并且，\n绝不会阻塞后面的语句。这和普通返回Promise对象的函数并无二\n致。\n注意：Promise.resolve(x)可以看作是newPromise(resolve=>\nresolve(x))的简写，可以用于快速封装字面量对象或其他对象，将\n其封装成Promise实例。\n34.async/await的优势\n单一的Promise链并不能发现async/await的优势，但是，如果需\n要处理由多个Promise组成的then链的时候，优势就能体现出来\n了（很有意思，Promise通过then链来解决多层回调的问题，现在\n又用async/await来进一步优化它）。\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于\n上一个步骤的结果。仍然用setTimeout来模拟异步操作：\n31\n现在用Promise方式来实现这三个步骤的处理：\n输出结果result是step3()的参数700+200=900。doIt()顺\n序执行了三个步骤，一共用了300+500+700=1500毫秒，和\nconsole.time()/console.timeEnd()计算的结果一致。\n如果用async/await来实现呢，会是这样：\n32\n结果和之前的Promise实现是一样的，但是这个代码看起来是不是\n清晰得多，几乎跟同步代码一样\n35.async/await对比Promise的优势\n代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的\n链式调⽤也会带来额外的阅读负担\nPromise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，\n⾮常优雅\n错误处理友好，async/await可以⽤成熟的try/catch，Promise的\n错误捕获⾮常冗余\n调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返\n回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤\n调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代\n码块，因为调试器只能跟踪同步代码的每⼀步。\n36.对象创建的方式有哪些？\n一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大\n量相似对象的时候，会产生大量的重复代码。但js和一般的面向对\n象的语言不同，在ES6之前它没有类的概念。但是可以使用函数来\n进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：\n33（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装\n创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一\n个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是\n简单的封装了复用代码，而没有建立起对象和类型间的关系。\n（2）第二种是构造函数模式。js中每一个函数都可以作为构造函数，\n只要一个函数是通过new来调用的，那么就可以把它称为构造函数。\n执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数\n的prototype属性，然后将执行上下文中的this指向这个对象，\n最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因\n为this的值指向了新建的对象，因此可以使用this给对象赋值。\n构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建\n立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存\n在一个缺点就是，造成了不必要的函数对象的创建，因为在js中函\n数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次\n都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有\n的实例都可以通用的。\n（3）第三种模式是原型模式，因为每一个函数都有一个prototype\n属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例\n都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方\n法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决\n了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有\n办法通过传入参数来初始化值，另一个是如果存在一个引用类型如\nArray这样的值，那么所有的实例将共享一个对象，一个实例对引用\n类型值的改变会影响所有的实例。\n34（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自\n定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存\n在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化\n对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的\n解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使\n用了两种不同的模式，所以对于代码的封装性不够好。\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创\n建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以\n实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式\n很好地对上面的混合模式进行了封装。\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实\n现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，\n在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函\n数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法\n实现对象的识别。\n37.对象继承的方式有哪些？\n（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在\n的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，\n容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传\n递参数。\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子\n类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不\n能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函\n数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n35（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数\n组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属\n性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继\n承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我\n们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构\n造函数，造成了子类型的原型中多了很多不必要的属性。\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已\n有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，\n然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为\n了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5\n中定义的Object.create()方法就是原型式继承的实现。缺点与原\n型链方式相同。\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于\n封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，\n然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解\n是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这\n个对象不是自定义类型时。缺点是没有办法实现函数的复用。\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类\n型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式\n组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这\n样就避免了创建不必要的属性。\n38.哪些情况会导致内存泄漏\n以下四种情况会造成内存的泄漏：\n36意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局\n变量，而使这个变量一直留在内存中无法被回收。\n被遗忘的计时器或回调函数：设置了setInterval定时器，而忘记\n取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被\n一直留在内存中，而无法被回收。\n脱离DOM的引用：获取一个DOM元素的引用，而后面这个元素被删\n除，由于一直保留了对这个元素的引用，所以它也无法被回收。\n闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。\nVUE部分\n1.Vue的基本原理\n当一个Vue实例创建时，Vue会遍历data中的属性，用\nObject.defineProperty（vue3.0使用proxy）将它们转为\ngetter/setter，并且在内部追踪相关依赖，在属性被访问和修改时\n通知变化。每个组件实例都有相应的watcher程序实例，它会在组\n件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用\n时，会通知watcher重新计算，从而致使它关联的组件得以更新。\n372.双向数据绑定的原理\nVue.js是采用数据劫持结合发布者-订阅者模式的方式，通过\nObject.defineProperty()来劫持各个属性的setter，getter，在数\n据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几\n个步骤：\n1.需要observe的数据对象进行递归遍历，包括子属性对象的属性，\n都加上setter和getter这样的话，给这个对象的某个值赋值，就会\n触发setter，那么就能监听到了数据变化\n2.compile解析模板指令，将模板中的变量替换成数据，然后初始化\n渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数\n据的订阅者，一旦数据有变动，收到通知，更新视图\n3.Watcher订阅者是Observer和Compile之间通信的桥梁，主要做\n的事情是:①在自身实例化时往属性订阅器(dep)里面添加自己②\n自身必须有一个update()方法③待属性变动dep.notice()通知时，\n能调用自身的update()方法，并触发Compile中绑定的回调，则功\n成身退。\n4.MVVM作为数据绑定的入口，整合Observer、Compile和Watcher\n三者，通过Observer来监听自己的model数据变化，通过Compile\n来解析编译模板指令，最终利用Watcher搭起Observer和Compile\n之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)\n->数据model变更的双向绑定效果。\n38\n3.MVVM、MVC、MVP的区别\nMVC、MVP和MVVM是三种常见的软件架构设计模式，主要通过分离\n关注点的方式来组织代码结构，优化开发效率。\n在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有\n的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户\n事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，\n可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗\n长、混乱，这样对项目开发和后期的项目维护是非常不利的。\n（1）MVC\nMVC通过分离Model、View和Controller的方式来组织代码结构。\n其中View负责页面的显示逻辑，Model负责存储页面的业务数据，\n以及对相应数据的操作。并且View和Model应用了观察者模式，\n当Model层发生改变的时候它会通知有关View层更新页面。\n39Controller层是View层和Model层的纽带，它主要负责用户与应\n用的响应操作，当用户与页面产生交互的时候，Controller中的事\n件触发器就开始工作了，通过调用Model层，来完成对Model的修\n改，然后Model层再去通知View层更新。\n（2）MVVM\nMVVM分为Model、View、ViewModel：\nModel代表数据模型，数据和业务逻辑都在Model层中定义；\nView代表UI视图，负责数据的展示；\nViewModel负责监听Model中数据的改变并且控制视图的更新，处理\n用户交互操作；\nModel和View并无直接关联，而是通过ViewModel来进行联系的，\nModel和ViewModel之间有着双向数据绑定的联系。因此当Model中\n的数据改变时会触发View层的刷新，View中由于用户交互操作而改\n变的数据也会在Model中同步。\n这种模式实现了Model和View的数据自动同步，因此开发者只需要\n专注于数据的维护操作即可，而不需要自己操作DOM。\n40\n（3）MVP\nMVP模式与MVC唯一不同的在于Presenter和Controller。在\nMVC模式中使用观察者模式，来实现当Model层数据发生变化的时\n候，通知View层的更新。这样View层和Model层耦合在一起，\n当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对\n代码的复用性造成一些问题。MVP的模式通过使用Presenter来实\n现对View层和Model层的解耦。MVC中的Controller只知道\nModel的接口，因此它没有办法控制View层的更新，MVP模式中，\nView层的接口暴露给了Presenter因此可以在Presenter中将\nModel的变化和View的变化绑定在一起，以此来实现View和\nModel的同步更新。这样就实现了对View和Model的解耦，\nPresenter还包含了其他的响应逻辑。\n4.slot是什么？有什么作用？原理是什么？\nslot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用\nslot元素作为承载分发内容的出口。插槽slot是子组件的一个模板\n标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决\n定的。slot又分三类，默认插槽，具名插槽和作用域插槽。\n默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个\n默认显示插槽，一个组件内只有有一个匿名插槽。\n41具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一\n个组件可以出现多个具名插槽。\n作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也\n可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可\n以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过\n来的数据决定如何渲染该插槽。\n实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的\n内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插\n槽为vm.$slot.xxx，xxx为插槽名，当组件执行渲染函数时候，遇\n到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递\n数据，若存在数据，则可称该插槽为作用域插槽。\n5.$nextTick原理及作用\nVue的nextTick其本质是对JavaScript执行原理EventLoop的\n一种应用。\nnextTick的核心是利用了如Promise、MutationObserver、\nsetImmediate、setTimeout的原生JavaScript方法来模拟对应的\n微/宏任务的实现，本质是为了利用JavaScript的这些异步回调任\n务队列来实现Vue框架中自己的异步回调队列。\nnextTick不仅是Vue内部的异步队列的调用方法，同时也允许开发\n者在实际项目中使用这个方法来满足实际应用中对DOM更新数据时\n机的后续逻辑处理\nnextTick是典型的将底层JavaScript执行原理应用到具体案例中\n的示例，引入异步更新队列机制的原因∶\n42如果是同步更新，则多次对一个或多个属性赋值，会频繁触发UI/DOM\n的渲染，可以减少一些无用渲染\n同时由于VirtualDOM的引入，每一次状态发生变化后，状态变化的\n信号会发送给组件，组件内部使用VirtualDOM进行计算得出需要更\n新的具体的DOM节点，然后对DOM进行更新操作，每次更新状态后\n的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所\n以异步渲染变得更加至关重要\nVue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作\nDOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2\n需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，\n这时就需要用到了nextTick了。\n由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2\n获取数据的操作写在$nextTick中。\n所以，在以下情况下，会用到nextTick：\n在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变\n化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函\n数中。\n在vue生命周期中，如果在created()钩子进行DOM操作，也一定要\n放在nextTick()的回调函数中。\n因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办\n法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在\nnextTick()的回调函数中。\n436.Vue单页应用与多页应用的区别\n概念：\nSPA单页面应用（SinglePageWebApplication），指只有一个主页\n面的应用，一开始只需要加载一次js、css等相关资源。所有内容都\n包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换\n相关组件，仅仅刷新局部资源。\nMPA多页面应用（MultiPageApplication），指有多个独立页面的\n应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，\n需要整页资源刷新。\n区别：\n447.Vue中封装的数组方法有哪些，其如何实现页面更新\n在Vue中，对响应式处理利用的是Object.defineProperty对数据进\n行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数\n组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到\n其中的变化。\n那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是\nVue中对这些方法的封装：\n45简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组\n的__ob__，也就是它的Observer对象，如果有新的值，就调用\nobserveArray继续对新的值观察变化（也就是通过target__proto__\n==arrayMethods来改变了数组实例的型），然后手动调用notify，\n通知渲染watcher，执行update。\n8.Vuedata中某一个属性的值发生改变后，视图会立即同步执\n行重新渲染吗？\n不会立即同步执行重新渲染。Vue实现响应式并不是数据发生变化之\n后DOM立即变化，而是按一定的策略进行DOM的更新。Vue在更新\nDOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，\n并缓冲在同一事件循环中发生的所有数据变更。\n如果同一个watcher被多次触发，只会被推入到队列中一次。这种在\n缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要\n的。然后，在下一个的事件循环tick中，Vue刷新队列并执行实际\n（已去重的）工作。\n9.简述mixin、extends的覆盖逻辑\n（1）mixin和extends\nmixin和extends均是用于合并、拓展组件的，两者均通过\nmergeOptions方法实现合并。\nmixins接收一个混入对象的数组，其中混入对象可以像正常的实例\n对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin\n钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。\nextends主要是为了便于扩展单文件组件，接收一个对象或构造函数。\n46\n（2）mergeOptions的执行过程\n规范化选项（normalizeProps、normalizelnject、\nnormalizeDirectives)\n对未合并的选项，进行判断\n10.子组件可以直接改变父组件的数据吗？\n子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组\n件的单向数据流。每次父级组件发生更新时，子组件中所有的prop\n都将会刷新为最新的值。如果这样做了，Vue会在浏览器的控制台中\n发出警告。\n47Vue提倡单向数据流，即父级props的更新会流向子组件，但是反\n过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据\n流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用\n复杂时，debug的成本会非常高。\n只能通过$emit派发一个自定义事件，父组件接收到后，由父组件\n修改。\n11.对React和Vue的理解，它们的异同\n相似之处：\n都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理\n交给相关的库；\n都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；\n都使用了VirtualDOM（虚拟DOM）提高重绘性能；\n都有props的概念，允许组件间的数据传递；\n都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用\n性。\n不同之处：\n1）数据流\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n2）虚拟DOM\nVue2.x开始引入\"VirtualDOM\"，消除了和React在这方面的差异，\n但是在具体的细节还是有各自的特点。\n48Vue宣称可以更快地计算出VirtualDOM的差异，这是由于它在渲染\n过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n对于React而言，每当应用的状态被改变时，全部子组件都会重新渲\n染。当然，这可以通过PureComponent/shouldComponentUpdate这\n个生命周期方法来进行控制，但Vue将此视为默认的优化。\n3）组件化\nReact与Vue最大的不同是模板的编写。\nVue鼓励写近似常规HTML的模板。写起来很接近标准HTML元素，只\n是多了一些属性。\nReact推荐你所有的模板通用JavaScript的语法扩展——JSX书写。\n具体来讲：React中render函数是支持闭包特性的，所以import的\n组件在render中可以直接调用。但是在Vue中，由于模板中使用的\n数据都必须挂在this上进行一次中转，所以import一个组件完了\n之后，还需要在components中再声明下。\n4）监听数据变化的实现原理不同\nVue通过getter/setter以及一些函数的劫持，能精确知道数据变\n化，不需要特别的优化就能达到很好的性能\nReact默认是通过比较引用的方式进行的，如果不优化\n（PureComponent/shouldComponentUpdate）可能导致大量不必要的\nvDOM的重新渲染。这是因为Vue使用的是可变数据，而React更强\n调数据的不可变。\n5）高阶组件\n49react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来\n扩展。\n高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以\n高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视\n图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。\n6）构建工具\n两者都有自己的构建工具：\nReact==>CreateReactAPP\nVue==>vue-cli\n7）跨平台\nReact==>ReactNative\nVue==>Weex\n12.Vue的优点\n轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有\n几十kb；\n简单易学：国人开发，中文文档，不存在语言障碍，易于理解和学\n习；\n双向数据绑定：保留了angular的特点，在数据操作方面更为简单；\n组件化：保留了react的优点，实现了html的封装和重用，在构\n建单页面应用方面有着独特的优势；\n视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代\n码的修改，只需要操作数据就能完成相关操作；\n50虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作\n节点，极大解放dom操作，但具体操作的还是dom不过是换了另一\n种方式；\n运行速度更快：相比较于react而言，同样是操作虚拟dom，就性\n能而言，vue存在很大的优势。\n13.assets和static的区别\n相同点：assets和static两个都是存放静态资源文件。项目中所\n需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件\n下，这是相同点\n不相同点：assets中存放的静态资源文件在项目打包时，也就是运\n行npmrunbuild时会将assets中放置的静态资源文件进行打包\n上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后\n的静态资源文件最终也都会放置在static文件中跟着index.html\n一同上传至服务器。static中放置的静态资源文件就不会要走打包\n压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。\n因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是\nstatic中的资源文件由于没有进行压缩等操作，所以文件的体积也\n就相对于assets中打包后的文件提交较大点。在服务器中就会占据\n更大的空间。\n建议：将项目中template需要的样式文件js文件等都可以放置在\nassets中，走打包这一流程。减少体积。而项目中引入的第三方的\n资源文件如iconfoont.css等文件可以放置在static中，因为这\n些引入的第三方文件已经经过处理，不再需要处理，直接上传。\n14.delete和Vue.delete删除数组的区别\n51delete只是被删除的元素变成了empty/undefined其他的元素的\n键值还是不变。\nVue.delete直接删除了数组改变了数组的键值。\n15.Vue模版编译原理\nvue中的模板template无法被浏览器解析并渲染，因为这不属于浏\n览器的标准，不是正确的HTML语法，所有需要将template转化成一\n个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对\n应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成\n为模板编译。模板编译又分三个阶段，解析parse，优化optimize，\n生成generate，最终生成可执行函数render。\n解析阶段：使用大量的正则表达式对template字符串进行解析，将\n标签、指令、属性等转化为抽象语法树AST。\n优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在\n页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优\n化runtime的性能。\n生成阶段：将最终的AST转化为render函数字符串。\n16.vue初始化页面闪动问题\n使用vue开发时，在vue初始化之前，由于div是不归vue管的，所\n以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类\n似于{{message}}的字样，虽然一般情况下这个时间很短暂，但是还\n是有必要让解决这个问题的。\n首先：在css里加上以下代码：\n52\n如果没有彻底解决问题，则在根元素加上style=\"display:\nnone;\":style=\"{display:'block'}\"\n17.MVVM的优缺点?\n优点:\n分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者\n逻辑的重⽤性:⽐如视图（View）可以独⽴于Model变化和修改，⼀\n个ViewModel可以绑定不同的\"View\"上，当View变化的时候Model\n不可以不变，当Model变化的时候View也可以不变。你可以把⼀些\n视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑\n提⾼可测试性:ViewModel的存在可以帮助开发者更好地编写测试代\n码\n⾃动更新dom:利⽤双向绑定,数据更新后视图⾃动更新,让开发者从\n繁琐的⼿动dom中解放\n缺点:\nBug很难被调试:因为使⽤双向绑定的模式，当你看到界⾯异常了，\n有可能是你View的代码有Bug，也可能是Model的代码有问题。数\n据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问\n题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写\n在View的模版当中的，这些内容是没办法去打断点debug的\n⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数\n据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存\n53对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护\n的成本都会⽐较⾼。\n18.v-if和v-for哪个优先级更高？如果同时出现，应如何优\n化？\nv-for优先于v-if被解析，如果同时出现，每次渲染都会先执行循\n环再判断条件，无论如何循环都不可避免，浪费了性能。\n要避免出现这种情况，则在外层嵌套template，在这一层进行v-if\n判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通\n过计算属性提前过滤掉那些不需要显示的项。\n19.对Vue组件化的理解\n1.组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之\n一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；\n2.组件化开发能大幅提高应用开发效率、测试性、复用性等；\n3.组件使用按分类有：页面组件、业务组件、通用组件；\n4.vue的组件是基于配置的，我们通常编写的组件是组件配置而非组\n件，框架后续会生成其构造函数，它们基于VueComponent，扩展于\nVue；\n5.vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们\n主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性\n能；\n6.组件应该是高内聚、低耦合的；\n7.遵循单向数据流的原则。\n20.对vue设计原则的理解\n541.渐进式JavaScript框架：与其它大型框架不同的是，Vue被设计\n为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上\n手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工\n具链以及各种支持类库结合使用时，Vue也完全能够为复杂的单页应\n用提供驱动。\n2.易用性：vue提供数据响应式、声明式模板语法和基于配置的组件\n系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要\n会写js、html和css就能轻松编写vue应用。\n3.灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我\n们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，\n我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是\n应用体积还是学习难度都是一个逐渐增加的平和曲线。\n4.高效性：超快的虚拟DOM和diﬀ算法使我们的应用拥有最佳的性能\n表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式\n改进以及编译器中对于静态内容编译的改进都会让vue更加高效。\n21.说一下Vue的生命周期\nVue实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、\n编译模版、挂载Dom->渲染、更新->渲染、卸载等⼀系列过程，\n称这是Vue的⽣命周期。\n1.beforeCreate（创建前）：数据观测和初始化事件还未开始，此时\ndata的响应式追踪、event/watcher都还没有被设置，也就是说不\n能访问到data、computed、watch、methods上的方法和数据。\n552.created（创建后）：实例创建完成，实例上配置的options包\n括data、computed、watch、methods等都配置完成，但是此时渲染\n得节点还未挂载到DOM，所以不能访问到$el属性。\n3.beforeMount（挂载前）：在挂载开始之前被调用，相关的render\n函数首次被调用。实例已完成以下的配置：编译模板，把data里面\n的数据和模板生成html。此时还没有挂载html到页面上。\n4.mounted（挂载后）：在el被新创建的vm.$el替换，并挂载到实\n例上去之后调用。实例已完成以下的配置：用上面编译好的html内\n容替换el属性指向的DOM对象。完成模板中的html渲染到html页\n面中。此过程中进行ajax交互。\n5.beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应\n式数据更新了，但是对应的真实DOM还没有被渲染。\n6.updated（更新后）：在由于数据更改导致的虚拟DOM重新渲染和\n打补丁之后调用。此时DOM已经根据响应式数据的变化更新了。调\n用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而\n在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更\n新无限循环。该钩子在服务器端渲染期间不被调用。\n7.beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍\n然完全可用，this仍能获取到实例。\n8.destroyed（销毁后）：实例销毁后调用，调用后，Vue实例指示\n的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例\n也会被销毁。该钩子在服务端渲染期间不被调用。\n56另外还有keep-alive独有的生命周期，分别为activated和\ndeactivated。用keep-alive包裹的组件在切换时不会进行销毁，而\n是缓存到内存中并执行deactivated钩子函数，命中缓存渲染后会执\n行activated钩子函数。\n22.Vue子组件和父组件执行顺序\n加载渲染过程：\n1.父组件beforeCreate\n2.父组件created\n3.父组件beforeMount\n4.子组件beforeCreate\n5.子组件created\n6.子组件beforeMount\n7.子组件mounted\n8.父组件mounted\n更新过程：\n1.父组件beforeUpdate\n2.子组件beforeUpdate\n3.子组件updated\n4.父组件updated\n销毁过程：\n1.父组件beforeDestroy\n572.子组件beforeDestroy\n3.子组件destroyed\n4.父组件destoryed\n23.created和mounted的区别\ncreated:在模板渲染成html前调用，即通常初始化某些属性值，然\n后再渲染成视图。\nmounted:在模板渲染成html后调用，通常是初始化页面完成后，再\n对html的dom节点进行一些需要的操作。\n4.一般在哪个生命周期请求异步数据\n我们可以在钩子函数created、beforeMount、mounted中进行调用，\n因为在这三个钩子函数中，data已经创建，可以将服务端端返回的\n数据进行赋值。\n推荐在created钩子函数中调用异步请求，因为在created钩子函\n数中调用异步请求有以下优点：\n能更快获取到服务端数据，减少页面加载时间，用户体验更好；\nSSR不支持beforeMount、mounted钩子函数，放在created中有\n助于一致性。\n24.keep-alive中的生命周期哪些\nkeep-alive是Vue提供的一个内置组件，用来对组件进行缓存——\n在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n58如果为一个组件包裹了keep-alive，那么它会多出两个生命周期：\ndeactivated、activated。同时，beforeDestroy和destroyed就\n不会再被触发了，因为组件不会被真正销毁。\n当组件被换掉时，会被缓存到内存中、触发deactivated生命周期；\n当组件被切回来时，再去缓存里找这个组件、触发activated钩子\n函数。\n25.路由的hash和history模式的区别\nVue-Router有两种模式：hash模式和history模式。默认的路由模\n式是hash模式。\n1.hash模式\n简介：hash模式是开发中默认的模式，它的URL带着一个#，例如：\nhttp://www.abc.com/#/vue，它的hash值就是#/vue。\n特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对\n后端完全没有影响。所以改变hash值，不会重新加载页面。这种模\n式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash\n路由被称为是前端路由，已经成为SPA（单页面应用）的标配。\n原理：hash模式的主要原理就是onhashchange()事件：\n使用onhashchange()事件的好处就是，在页面的hash值发生变化时，\n无需向后端发起请求，window就可以监听事件的改变，并按规则加\n载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记\n59录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后\n端服务器，但是页面的hash值和对应的URL关联起来了。\n2.history模式\n简介：history模式的URL中没有#，它使用的是传统的路由分发模\n式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个\nURL，然后做出相应的逻辑处理。\n特点：当使用history模式时，URL就像这样：\nhttp://abc.com/user/id。相比hash模式更加好看。但是，history\n模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。\nAPI：historyapi可以分为两大部分，切换历史状态和修改历史状\n态：\n修改历史状态：包括了HTML5HistoryInterface中新增的\npushState()和replaceState()方法，这两个方法应用于浏览器的\n历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修\n改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要\n做到改变url但又不刷新页面的效果，就需要前端用上这两个API。\n切换历史状态：包括forward()、back()、go()三个方法，对应浏\n览器的前进，后退，跳转操作。\n虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是\n在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。\n如果想要切换到history模式，就要进行以下配置（后端也要进行配\n置）：\n60\n3.两种模式对比\n调用history.pushState()相比于直接修改hash，存在以下优势:\npushState()设置的新URL可以是与当前URL同源的任意URL；而\nhash只可修改#后面的部分，因此只能设置与当前URL同文档的\nURL；\npushState()设置的新URL可以与当前URL一模一样，这样也会把\n记录添加到栈中；而hash设置的新值必须与原来不一样才会触发动\n作将记录添加到栈中；\npushState()通过stateObject参数可以添加任意类型的数据到记\n录中；而hash只可添加短字符串；\npushState()可额外设置title属性供后续使用。\nhash模式下，仅hash符号之前的url会被包含在请求中，后端如果\n没有做到对路由的全覆盖，也不会返回404错误；history模式下，\n前端的url必须和实际向后端发起请求的url一致，如果没有对用的\n路由处理，将返回404错误。\nhash模式和history模式都有各自的优势和缺陷，还是要根据实际\n情况选择性的使用。\n26.Vue-router跳转和location.href有什么区别\n使用location.href=/url来跳转，简单方便，但是刷新了页面；\n使用history.pushState(/url)，无刷新页面，静态跳转；\n61引进router，然后使用router.push(/url)来跳转，使用了diff\n算法，实现了按需加载，减少了dom的消耗。其实使用router跳\n转和使用history.pushState()没什么差别的，因为vue-router就\n是用了history.pushState()，尤其是在history模式下。\n27.Vuex的原理\nVuex是一个专为Vue.js应用程序开发的状态管理模式。每一个\nVuex应用的核心就是store（仓库）。“store”基本上就是一个\n容器，它包含着你的应用中大部分的状态(state)。\nVuex的状态存储是响应式的。当Vue组件从store中读取状态的\n时候，若store中的状态发生变化，那么相应的组件也会相应地得\n到高效更新。\n改变store中的状态的唯一途径就是显式地提交(commit)\nmutation。这样可以方便地跟踪每一个状态的变化。\n62Vuex为VueComponents建立起了一个完整的生态圈，包括开发中的\nAPI调用一环。\n（1）核心流程中的主要功能：\nVueComponents是vue组件，组件会触发（dispatch）一些事件或\n动作，也就是图中的Actions;\n在组件中发出的动作，肯定是想获取或者改变数据的，但是在vuex\n中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提\n交（Commit）到Mutations中;\n然后Mutations就去改变（Mutate）State中的数据;\n当State中的数据被改变之后，就会重新渲染（Render）到Vue\nComponents中去，组件展示更新后的数据，完成一个流程。\n（2）各模块在核心流程中的主要功能：\nVueComponents∶Vue组件。HTML页面上，负责接收用户操作等交\n互行为，执行dispatch方法触发对应action进行回应。\ndispatch∶操作行为触发方法，是唯一能执行action的方法。\nactions∶操作行为处理模块。负责处理VueComponents接收到的\n所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册\n的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括\n触发其他action以及提交mutation的操作。该模块提供了Promise\n的封装，以支持action的链式触发。\ncommit∶状态改变提交操作方法。对mutation进行提交，是唯一能\n执行mutation的方法。\n63mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，\n其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且\n方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行\nstate的监控等。\nstate∶页面状态管理容器对象。集中存储Vuecomponents中data\n对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需\n的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行\n高效的状态更新。\ngetters∶state对象读取方法。图中没有单独列出该模块，应该被\n包含在了render中，VueComponents通过该方法读取全局state对\n象。\n总结：\nVuex实现了一个单向数据流，在全局拥有一个State存放数据，当\n组件要更改State中的数据时，必须通过Mutation提交修改信息，\nMutation同时提供了订阅者模式供外部插件调用获取State数据\n的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)\n或批量的同步操作需要走Action，但Action也是无法直接修改\nState的，还是需要通过Mutation来修改State的数据。最后，根\n据State的变化，渲染到视图上。\n28.Vuex和localStorage的区别\n（1）最重要的区别\nvuex存储在内存中\n64localstorage则以文件的方式存储在本地，只能存储字符串类型的\n数据，存储对象需要JSON的stringify和parse方法进行处理。读\n取内存比读取硬盘速度要快\n（2）应用场景\nVuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集\n中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一\n种可预测的方式发生变化。vuex用于组件之间的传值。\nlocalstorage是本地存储，是将数据存储到浏览器的方法，一般是\n在跨页面传递数据时使用。\nVuex能做到数据的响应式，localstorage不能\n（3）永久性\n刷新页面时vuex存储的值会丢失，localstorage不会。\n注意：对于不变的数据确实可以用localstorage可以代替vuex，但\n是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件\n改变了该数据源，希望另一个组件响应该变化时，localstorage无\n法做到，原因就是区别1。\n29.Redux和Vuex有什么区别，它们的共同思想\n（1）Redux和Vuex区别\nVuex改进了Redux中的Action和Reducer函数，以mutations变化\n函数取代Reducer，无需switch，只需在对应的mutation函数里改\n变state值即可\nVuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要\n生成新的State即可\n65Vuex数据流的顺序是∶View调用store.commit提交对应的请求到\nStore中对应的mutation函数->store改变（vue检测到数据变化自\n动渲染）\n通俗点理解就是，vuex弱化dispatch，通过commit进行store状\n态的一次更变;取消了action概念，不必传入特定的action形式进\n行指定变更;弱化reducer，基于commit参数直接对数据进行转变，\n使得框架更加简易;\n（2）共同思想\n单—的数据源\n变化可以预测\n本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽\n离的一种方案;\n形式上：vuex借鉴了redux，将store作为全局的数据中心，进行\nmode管理;\n30.为什么要用Vuex或者Redux\n由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组\n件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通\n过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通\n常会导致代码无法维护。\n所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在\n这种模式下，组件树构成了一个巨大的\"视图\"，不管在树的哪个位置，\n任何组件都能获取状态或者触发行为。\n66另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，\n代码将会变得更结构化且易维护。\n31.Vuex有哪几种属性？\n有五种，分别是State、Getter、Mutation、Action、Module\nstate=>基本数据(数据源存放地)\ngetters=>从基本数据派生出来的数据\nmutations=>提交更改数据的方法，同步\nactions=>像一个装饰器，包裹mutations，使之可以异步。\nmodules=>模块化Vuex\n32.Vuex和单纯的全局对象有什么区别？\nVuex的状态存储是响应式的。当Vue组件从store中读取状态的\n时候，若store中的状态发生变化，那么相应的组件也会相应地得\n到高效更新。\n不能直接改变store中的状态。改变store中的状态的唯一途径就\n是显式地提交(commit)mutation。这样可以方便地跟踪每一个状态\n的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n33.为什么Vuex的mutation中不能做异步操作？\nVuex中所有的状态更新的唯一途径都是mutation，异步操作通过\nAction来提交mutation实现，这样可以方便地跟踪每一个状态的\n变化，从而能够实现一些工具帮助更好地了解我们的应用。\n每个mutation执行完成后都会对应到一个新的状态变更，这样\ndevtools就可以打个快照存下来，然后就可以实现time-travel了。\n67如果mutation支持异步操作，就没有办法知道状态是何时更新的，\n无法很好的进行状态的追踪，给调试带来困难。\n34.Vue3.0有什么更新\n（1）监测机制的改变\n3.0将带来基于代理Proxy的observer实现，提供全语言覆盖的\n反应性跟踪。\n消除了Vue2当中基于Object.defineProperty的实现所存在的\n很多限制：\n（2）只能监测属性，不能监测对象\n检测属性的添加和删除；\n检测数组索引和长度的变更；\n支持Map、Set、WeakMap和WeakSet。\n（3）模板\n作用域插槽，2.x的机制导致作用域插槽变了，父组件会重新渲染，\n而3.0把作用域插槽改成了函数的方式，这样只会影响子组件的重\n新渲染，提升了渲染的性能。\n同时，对于render函数的方面，vue3.0也会进行一系列更改来方\n便习惯直接使用api来生成vdom。\n（4）对象式的组件声明方式\nvue2.x中的组件是通过声明的方式传入一系列option，和\nTypeScript的结合需要通过一些装饰器的方式来做，虽然能实现功\n能，但是比较麻烦。\n683.0修改了组件的声明方式，改成了类式的写法，这样使得和\nTypeScript的结合变得很容易\n（5）其它方面的更改\n支持自定义渲染器，从而使得weex可以通过自定义渲染器的方式来\n扩展，而不是直接fork源码来改的方式。\n支持Fragment（多个根节点）和Protal（在dom其他部分渲染组\n建内容）组件，针对一些特殊的场景做了处理。\n基于treeshaking优化，提供了更多的内置功能。\n35.defineProperty和proxy的区别\nVue在实例初始化时遍历data中的所有属性，并使用\nObject.defineProperty把这些属性全部转为getter/setter。这样\n当追踪数据发生变化时，setter会被自动调用。\nObject.defineProperty是ES5中一个无法shim的特性，这也就\n是Vue不支持IE8以及更低版本浏览器的原因。\n但是这样做有以下问题：\n1.添加或删除对象的属性时，Vue检测不到。因为添加或删除的对象\n没有在初始化进行响应式处理，只能通过$set来调用\nObject.defineProperty()处理。\n2.无法监控到数组下标和长度的变化。\nVue3使用Proxy来监控数据的变化。Proxy是ES6中提供的功能，\n其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚\n举，函数调用等）。相对于Object.defineProperty()，其有以下特\n点：\n691.Proxy直接代理整个对象而非对象属性，这样只需做一层代理就可\n以监听同级结构下的所有属性变化，包括新增属性和删除属性。\n2.Proxy可以监听数组的变化。\n36.Vue3.0为什么要用proxy？\n在Vue2中，0bject.defineProperty会改变原始数据，而Proxy\n是创建对象的虚拟表示，并提供set、get和deleteProperty等\n处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，\n有以下特点∶\n不需用使用Vue.$set或Vue.$delete触发响应式。\n全方位的数组变化检测，消除了Vue2无效的边界情况。\n支持Map，Set，WeakMap和WeakSet。\nProxy实现的响应式原理与Vue2的实现原理相同，实现方式大同小\n异∶\nget收集依赖\nSet、delete等触发依赖\n对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执\n行依赖相关的收集或触发逻辑。\n37.虚拟DOM的解析过程\n虚拟DOM的解析过程：\n首先对将要插入到文档中的DOM树结构进行分析，使用js对象将\n其表示出来，比如一个元素对象，包含TagName、props和Children\n70这些属性。然后将这个js对象树给保存下来，最后再将DOM片段\n插入到文档中。\n当页面的状态发生改变，需要对页面的DOM的结构进行调整的时候，\n首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象\n树和旧的对象树进行比较，记录下两棵树的的差异。\n最后将记录的有差异的地方应用到真正的DOM树中去，这样视图就\n更新了。\n38.DIFF算法的原理\n在新老虚拟DOM对比时：\n首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则\n删除该节点重新创建节点进行替换\n如果为相同节点，进行patchVnode，判断如何对该节点的子节点进\n行处理，先判断一方有子节点一方没有子节点的情况(如果新的\nchildren没有子节点，将旧的子节点移除)\n比较如果都有子节点，则进行updateChildren，判断如何对这些新\n老节点的子节点进行操作（diff核心）。\n匹配时，找到相同的子节点，递归比较子节点\n在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使\n得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children\n都为多个子节点时才需要用核心的Diff算法进行同层级比较。\n39.Vue中key的作用\nvue中key值的作用可以分为两种情况来考虑：\n71第一种情况是v-if中使用key。由于Vue会尽可能高效地渲染元\n素，通常会复用已有元素而不是从头开始渲染。因此当使用v-if来\n实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个\n元素就会被复用。如果是相同的input元素，那么切换前后用户的\n输入不会被清除掉，这样是不符合需求的。因此可以通过使用key来\n唯一的标识一个元素，这个情况下，使用key的元素不会被复用。\n这个时候key的作用是用来标识一个独立的元素。\n第二种情况是v-for中使用key。用v-for更新已渲染过的元素列\n表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改\n变，Vue不会移动DOM元素来匹配数据项的顺序，而是简单复用此\n处的每个元素。因此通过为每个列表项提供一个key值，来以便Vue\n跟踪元素的身份，从而高效的实现复用。这个时候key的作用是为\n了高效的更新渲染虚拟DOM。\nkey是为Vue中vnode的唯一标记，通过这个key，diff操作可\n以更准确、更快速\n更准确：因为带key就不是就地复用了，在sameNode函数a.key\n===b.key对比中可以避免就地复用的情况。所以会更加准确。\n更快速：利用key的唯一性生成map对象来获取对应节点，比遍历\n方式更快\nReact部分\n1.React的事件和普通的HTML事件有什么不同？\n区别：\n对于事件名称命名方式，原生事件为全小写，react事件采用小驼峰；\n72对于事件函数处理语法，原生事件为字符串，react事件为函数；\nreact事件不能采用returnfalse的方式来阻止浏览器的默认行\n为，而必须要地明确地调用preventDefault()来阻止默认行为。\n合成事件是react模拟原生DOM事件所有能力的一个事件对象，其\n优点如下：\n兼容所有浏览器，更好的跨平台；\n将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\n方便react统一管理和事务机制。\n事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒\n泡绑定到document上，所以尽量避免原生事件与合成事件混用，如\n果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到\ndocument上合成事件才会执行。\n2.React组件中怎么做事件代理？它的原理是什么？\nReact基于VirtualDOM实现了一个SyntheticEvent层（合成事件\n层），定义的事件处理器会接收到一个合成事件对象的实例，它符合\nW3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，\n所有的事件都自动绑定在最外层上。\n在React底层，主要对合成事件做了两件事：\n事件委派：React会把所有的事件绑定到结构的最外层，使用统一的\n事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部\n事件监听和处理函数。\n自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，\n即自动绑定this为当前组件。\n733.React高阶组件、Renderprops、hooks有什么区别，为什\n么要不断迭代\n这三者是目前react解决代码复用的主要方式：\n高阶组件（HOC）是React中用于复用组件逻辑的一种高级技巧。HOC\n自身不是ReactAPI的一部分，它是一种基于React的组合特性而\n形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组\n件的函数。\nrenderprops是指一种在React组件之间使用一个值为函数的\nprop共享代码的简单技术，更具体的说，renderprop是一个用于\n告知组件需要渲染什么内容的函数prop。\n通常，renderprops和高阶组件只渲染一个子节点。让Hook来服\n务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个\n虚拟滚动条组件或许会有一个renderltem属性，或是一个可见的容\n器组件或许会有它自己的DOM结构）。但在大部分场景下，Hook足\n够了，并且能够帮助减少嵌套。\n（1）HOC\n官方解释∶\n高阶组件（HOC）是React中用于复用组件逻辑的一种高级技巧。HOC\n自身不是ReactAPI的一部分，它是一种基于React的组合特性而\n形成的设计模式。\n简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参\n数（如果需要），返回一个新的组件。HOC是纯函数，没有副作用。\n74\nHOC的优缺点∶\n优点∶逻辑服用、不影响被包裹组件的内部逻辑。\n缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，\n进而被覆盖\n（2）Renderprops\n官方解释∶\n\"renderprop\"是指一种在React组件之间使用一个值为函数的\nprop共享代码的简单技术\n具有renderprop的组件接受一个返回React元素的函数，将render\n的渲染逻辑注入到组件内部。在这里，\"render\"的命名可以是任何其\n他有效的标识符。\n75\n由此可以看到，renderprops的优缺点也很明显∶\n优点：数据共享、代码复用，将组件内的state作为props传递给调\n用者，将渲染逻辑交给调用者。\n缺点：无法在return语句外访问数据、嵌套写法不够优雅\n（3）Hooks\n官方解释∶\nHook是React16.8的新增特性。它可以让你在不编写class的情\n况下使用state以及其他的React特性。通过自定义hook，可以\n复用代码逻辑。\n76以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方\n式解决了renderprops的嵌套地狱的问题。hook的优点如下∶\n使用直观；\n解决hoc的prop重名问题；\n解决renderprops因共享数据而出现嵌套地狱的问题；\n能在return之外使用数据的问题。\n需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。\n总结∶\nHoc、renderprops和hook都是为了解决代码复用的问题，但是hoc\n和renderprops都有特定的使用场景和明显的缺点。hook是\nreact16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解\n决了hoc和renderprops的一些缺点。\n4.Component,Element,Instance之间有什么区别和联系？\n元素：一个元素element是一个普通对象(plainobject)，描述了对\n于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成\n什么样子。元素element可以在它的属性props中包含其他元素(译\n注:用于形成元素树)。创建一个React元素element成本很低。元素\nelement创建之后是不可变的。\n组件：一个组件component可以通过多种方式声明。可以是带有一个\nrender()方法的类，简单点也可以定义为一个函数。这两种情况下，\n它都把属性props作为输入，把返回的一棵元素树作为输出。\n77实例：一个实例instance是你在所写的组件类componentclass中\n使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状\n态和响应生命周期事件很有用。\n函数式组件(Functionalcomponent)根本没有实例instance。类组\n件(Classcomponent)有实例instance，但是永远也不需要直接创建\n一个组件的实例，因为React帮我们做了这些。\n5.React.createClass和extendsComponent的区别有哪些？\nReact.createClass和extendsComponent的bai区别主要在于：\n（1）语法区别\ncreateClass本质上是一个工厂函数，extends的方式更加接近最新\n的ES6规范的class写法。两种方式在语法上的差别主要体现在方法\n的定义和静态属性的声明上。\ncreateClass方式的方法定义使用逗号，隔开，因为creatClass本\n质上是一个函数，传递给它的是一个Object；而class的方式定义\n方法时务必谨记不要使用逗号隔开，这是ES6class的语法规范。\n（2）propType和getDefaultProps\nReact.createClass：通过proTypes对象和getDefaultProps()方法\n来设置和获取props.\nReact.Component：通过设置两个属性propTypes和defaultProps\n（3）状态的区别\nReact.createClass：通过getInitialState()方法返回一个包含初\n始值的对象\nReact.Component：通过constructor设置初始状态\n78（4）this区别\nReact.createClass：会正确绑定this\nReact.Component：由于使用了ES6，这里会有些微不同，属性并不\n会自动绑定到React类的实例上。\n（5）Mixins\nReact.createClass：使用React.createClass的话，可以在创建组\n件时添加一个叫做mixins的属性，并将可供混合的类的集合以数组\n的形式赋给mixins。\n如果使用ES6的方式来创建组件，那么Reactmixins的特性将不\n能被使用了。\n6.React如何判断什么时候重新渲染组件？\n组件状态的改变可以因为props的改变，或者直接通过setState方\n法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。\n只要组件的state发生变化，React就会对组件进行重新渲染。这是\n因为React中的shouldComponentUpdate方法默认返回true，这就\n是导致每次更新都重新渲染的原因。\n当React将要渲染组件时会执行shouldComponentUpdate方法来看它\n是否返回true（组件应该更新，也就是重新渲染）。所以需要重写\nshouldComponentUpdate方法让它根据情况返回true或者false来\n告诉React什么时候重新渲染什么时候跳过重新渲染。\n7.React中可以在render访问refs吗？为什么？\n不可以，render阶段DOM还没有生成，无法获取DOM。DOM的获取\n需要在pre-commit阶段和commit阶段：\n79\n8.ReactsetState调用之后发生了什么？是同步还是异步？\n（1）React中setState后发生了什么\n在代码中调用setState函数之后，React会将传入的参数对象与组\n件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和\n过程，React会以相对高效的方式根据新的状态构建React元素树\n并且着手重新渲染整个UI界面。\n在React得到元素树之后，React会自动计算出新的树与老树的节\n点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，\nReact能够相对精确地知道哪些位置发生了改变以及应该如何改变，\n这就保证了按需更新，而不是全部重新渲染。\n如果在短时间内频繁setState。React会将state的改变压入栈中，\n在合适的时机，批量更新state和视图，达到提高性能的效果。\n（2）setState是同步还是异步的\n80假如所有setState是同步的，意味着每执行一次setState时（有可\n能一个同步代码中，多次setState），都重新vnodediff+dom修\n改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代\n码中的多个setState合并成一次组件更新。所以默认是异步的，但\n是在一些情况下是同步的。\nsetState并不是单纯同步/异步的，它的表现会因调用场景的不同而\n不同。在源码中，通过isBatchingUpdates来判断setState是先\n存进state队列还是直接更新，如果值为true则执行异步操作，\n为false则直接更新。\n异步：在React可以控制的地方，就为true，比如在React生命\n周期事件和合成事件中，都会走合并操作，延迟更新的策略。\n同步：在React无法控制的地方，比如原生事件，具体就是在\naddEventListener、setTimeout、setInterval等事件中，就只能\n同步更新。\n一般认为，做异步设计是为了性能优化、减少渲染次数：\nsetState设计为异步，可以显著的提升性能。如果每次调用setState\n都进行一次更新，那么意味着render函数会被频繁调用，界面重新\n渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后\n进行批量更新；\n如果同步更新了state，但是还没有执行render函数，那么state\n和props不能保持同步。state和props不能保持一致性，会在开发\n中产生很多的问题；\n9.React组件的state和props有什么区别？\n（1）props\n81props是一个从外部传进组件的参数，主要作为就是从父组件向子组\n件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新\n的props来重新渲染子组件，否则子组件的props以及展现形式不会\n改变。\n（2）state\nstate的主要作用是用于组件保存、控制以及修改自己的状态，它只\n能在constructor中初始化，它算是组件的私有属性，不可通过外部\n访问和修改，只能通过组件内部的this.setState来修改，修改state\n属性会导致组件的重新渲染。\n（3）区别\nprops是传递给组件的（类似于函数的形参），而state是在组件\n内被组件自己管理的（类似于在一个函数内声明的变量）。\nprops是不可修改的，所有React组件都必须像纯函数一样保护它\n们的props不被更改。\nstate是在组件中创建的，一般在constructor中初始化state。\nstate是多变的、可以修改，每次setState都异步更新的。\n10.React中的props为什么是只读的？\nthis.props是组件之间沟通的一个接口，原则上来讲，它只能从父\n组件流向子组件。React具有浓重的函数式编程的思想。\n提到函数式编程就要提一个概念：纯函数。它有几个特点：\n给定相同的输入，总是返回相同的输出。\n过程没有副作用。\n不依赖外部状态。\n82this.props就是汲取了纯函数的思想。props的不可以变性就保证的\n相同的输入，页面显示的内容是一样的，并且不会产生副作用\n11.React中怎么检验props？验证props的目的是什么？\nReact为我们提供了PropTypes以供验证使用。当我们向Props传入\n的数据无效（向Props传入的数据类型和验证的数据类型不符）就会\n在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的\n问题。并且，它还可以让程序变得更易读。\n当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes\n来校验，而使用TypeScript定义接口来校验props。\n2.React废弃了哪些生命周期？为什么？\n被废弃的三个函数都是在render之前，因为fber的出现，很可能因\n为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外\n的一个原因则是，React想约束使用者，好的框架能够让人不得已写\n出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及\n即将废弃的生命周期分析入手\n1)componentWillMount\n首先这个函数的功能完全可以使用componentDidMount和\nconstructor来代替，异步获取的数据的情况上面已经说明了，而如\n83果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在\nconstructor中执行，除此之外，如果在willMount中订阅事件，\n但在服务端这并不会执行willUnMount事件，也就是说服务端会导\n致内存泄漏所以componentWilIMount完全可以不使用，但使用者有\n时候难免因为各种各样的情况在componentWilMount中做一些操作，\n那么React为了约束开发者，干脆就抛掉了这个API\n2)componentWillReceiveProps\n在老版本的React中，如果组件自身的某个state跟其props密\n切相关的话，一直都没有一种很优雅的处理方式去更新state，而是\n需要在componentWilReceiveProps中判断前后两个props是否相\n同，如果不同再将新的props更新到相应的state上去。这样做一\n来会破坏state数据的单一数据源，导致组件状态变得不可预测，\n另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一\n个可以横向滑动的列表，当前高亮的Tab显然隶属于列表自身的时，\n根据传入的某个值，直接定位到某个Tab。为了解决这些问题，React\n引入了第一个新的生命周期：getDerivedStateFromProps。它有以下\n的优点∶\n●getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，\n开发者不能写出副作用的代码\n●开发者只能通过prevState而不是prevProps来做对比，保证了\nstate和props之间的简单关系以及不需要处理第一次渲染时\nprevProps为空的情况\n●基于第一点，将状态变化（setState）和昂贵操作（tabChange）\n区分开，更加便于render和commit阶段操作或者说优化。\n3)componentWillUpdate\n84与componentWillReceiveProps类似，许多开发者也会在\ncomponentWillUpdate中根据props的变化去触发一些回调。但\n不论是componentWilReceiveProps还是componentWilUpdate，都\n有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有\n可能会被调用多次，这显然是不可取的。与componentDidMount类\n似，componentDidUpdate也不存在这样的问题，一次更新中\ncomponentDidUpdate只会被调用一次，所以将原先写在\ncomponentWillUpdate中的回调迁移至componentDidUpdate\n就可以解决这个问题。\n另外一种情况则是需要获取DOM元素状态，但是由于在fber中，\nrender可打断，可能在wilMount中获取到的元素状态很可能与实际\n需要的不同，这个通常可以使用第二个新增的生命函数的解决\ngetSnapshotBeforeUpdate(prevProps,prevState)\n4)getSnapshotBeforeUpdate(prevProps,prevState)\n返回的值作为componentDidUpdate的第三个参数。与willMount不\n同的是，getSnapshotBeforeUpdate会在最终确定的render执行之\n前执行，也就是能保证其获取到的元素状态与didUpdate中获取到的\n元素状态相同。官方参考代码：\n85\n12.React16.X中props改变后在哪个生命周期中处理\n在getDerivedStateFromProps中进行处理。\n这个生命周期函数是为了替代componentWillReceiveProps存在的，\n所以在需要使用componentWillReceiveProps时，就可以考虑使用\ngetDerivedStateFromProps来进行替代。\n两者的参数是不相同的，而getDerivedStateFromProps是一个静态\n函数，也就是这个函数不能通过this访问到class的属性，也并不\n推荐直接访问属性。而是应该通过参数提供的nextProps以及\nprevState来进行判断，根据新传入的props来映射到state。\n86需要注意的是，如果props传入的内容不需要影响到你的state，那\n么就需要返回一个null，这个返回值是必须的，所以尽量将其写到\n函数的末尾：\n13.React16中新生命周期有哪些\n关于React16开始应用的新生命周期：\n可以看出，React16自上而下地对生命周期做了另一种维度的解读：\nRender阶段：用于计算一些必要的状态信息。这个阶段可能会被\nReact暂停，这一点和React16引入的Fiber架构（我们后面会重\n点讲解）是有关的；\n87Pre-commit阶段：所谓“commit”，这里指的是“更新真正的DOM节\n点”这个动作。所谓Pre-commit，就是说我在这个阶段其实还并没\n有去更新真实的DOM，不过DOM信息已经是可以读取的了；\nCommit阶段：在这一步，React会完成真实DOM的更新工作。Commit\n阶段，我们可以拿到真实DOM（包括refs）。\n与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、\n“卸载”这三个广义的划分方式。它们分别对应到：\n挂载过程：\nconstructor\ngetDerivedStateFromProps\nrender\ncomponentDidMount\n更新过程：\ngetDerivedStateFromProps\nshouldComponentUpdate\nrender\ngetSnapshotBeforeUpdate\ncomponentDidUpdate\n卸载过程：\ncomponentWillUnmount\n14.React-Router的实现原理是什么？\n客户端路由实现的思想：\n88基于hash的路由：通过监听hashchange事件，感知hash的变化\n改变hash可以直接通过location.hash=xxx\n基于H5history路由：\n改变url可以通过history.pushState和resplaceState等，会\n将URL压入堆栈，同时能够应用history.go()等API\n监听url的变化可以通过自定义事件触发实现\nreact-router实现的思想：\n基于history库来实现上述不同的客户端路由实现思想，并且能够\n保存历史记录等，磨平浏览器差异，上层无感知\n通过维护的列表，在每次URL发生变化的回收，通过配置的路由路\n径，匹配到对应的Component，并且render\n15.react-router里的Link标签和a标签的区别\n从最终渲染的DOM来看，这两者都是链接，都是标签，区别是∶\n<Link>是react-router里实现路由跳转的链接，一般配合<Route>\n使用，react-router接管了其默认的链接跳转行为，区别于传统的\n页面跳转，<Link>的“跳转”行为只会触发相匹配的<Route>对应的\n页面内容更新，而不会刷新整个页面。\n<Link>做了3件事情:\n有onclick那就执行onclick\nclick的时候阻止a标签默认事件\n根据跳转href(即是to)，用history(web前端路由两种方式之一，\nhistory&hash)跳转，此时只是链接变了，并没有刷新页面而<a>\n89标签就是普通的超链接了，用于从当前页面跳转到href指向的另一\n个页面(非锚点情况)。\na标签默认事件禁掉之后做了什么才实现了跳转?\n16.对Redux的理解，主要解决什么问题\nReact是视图层框架。Redux是一个用来管理数据状态和UI状态的\nJavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋\n复杂，JavaScript需要管理比任何时候都要多的state（状态），\nRedux就是降低管理难度的。（Redux支持React、Angular、jQuery\n甚至纯JavaScript）。\n在React中，UI以组件的形式来搭建，组件之间可以嵌套组合。但\nReact中组件间通信的数据流是单向的，顶层组件可以通过props\n属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄\n弟组件之间同样不能。这样简单的单向数据流支撑起了React中的\n数据可控性。\n当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也\n将越来越不好管理。管理不断变化的state非常困难。如果一个\nmodel的变化会引起另一个model变化，那么当view变化时，就\n可能引起对应model以及另一个model的变化，依次地，可能会引\n起另一个view的变化。直至你搞不清楚到底发生了什么。state在\n什么时候，由于什么原因，如何变化已然不受控制。当系统变得错\n综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果\n90这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、\n服务端渲染、路由跳转前请求数据等。state的管理在大项目中相当\n复杂。\nRedux提供了一个叫store的统一仓储库，组件通过dispatch将\nstate直接传入store，不用通过其他的组件。并且组件通过\nsubscribe从store获取到state的改变。使用了Redux，所有的\n组件都可以从store中获取到所需的state，他们也能从store获\n取到state的改变。这比组件之间互相传递数据清晰明朗的多。\n主要解决的问题：\n单纯的Redux只是一个状态机，是没有UI呈现的，react-redux作\n用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch\naction改变state的时候，会自动更新页面。\n17.Redux状态管理器和变量挂载到window中有什么区别\n两者都是存储数据以供后期使用。但是Redux状态更改可回溯——\nTimetravel，数据多了的时候可以很清晰的知道改动在哪里发生，\n完整的提供了一套状态管理模式。\n随着JavaScript单页应用开发日趋复杂，JavaScript需要管理比\n任何时候都要多的state（状态）。这些state可能包括服务器\n响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括UI\n状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器\n等等。\n管理不断变化的state非常困难。如果一个model的变化会引起另\n一个model变化，那么当view变化时，就可能引起对应model以\n及另一个model的变化，依次地，可能会引起另一个view的变化。\n91直至你搞不清楚到底发生了什么。state在什么时候，由于什么原因，\n如何变化已然不受控制。当系统变得错综复杂的时候，想重现问题\n或者添加新功能就会变得举步维艰。\n如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调\n优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前\n所未有的复杂性，难道就这么放弃了吗?当然不是。\n这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混\n淆在一起：变化和异步。可以称它们为曼妥思和可乐。如果把二者\n分开，能做的很好，但混到一起，就变得一团糟。一些库如React视\n图在视图层禁止异步和直接操作DOM来解决这个问题。美中不足的\n是，React依旧把处理state中数据的问题留给了你。Redux就是\n为了帮你解决这个问题。\n18.Redux和Vuex有什么区别，它们的共同思想\n（1）Redux和Vuex区别\nVuex改进了Redux中的Action和Reducer函数，以mutations变化\n函数取代Reducer，无需switch，只需在对应的mutation函数里改\n变state值即可\nVuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要\n生成新的State即可\nVuex数据流的顺序是∶View调用store.commit提交对应的请求到\nStore中对应的mutation函数->store改变（vue检测到数据变化自\n动渲染）\n通俗点理解就是，vuex弱化dispatch，通过commit进行store状\n态的一次更变；取消了action概念，不必传入特定的action形式\n92进行指定变更；弱化reducer，基于commit参数直接对数据进行转\n变，使得框架更加简易;\n（2）共同思想\n单—的数据源\n变化可以预测\n本质上∶redux与vuex都是对mvvm思想的服务，将数据从视图中\n抽离的一种方案。\n19.Redux中间件是怎么拿到store和action?然后怎么处\n理?\nredux中间件本质就是一个函数柯里化。reduxapplyMiddlewareApi\n源码中每个middleware接受2个参数，Store的getState函数和\ndispatch函数，分别获得store和action，最终返回一个函数。该\n函数会被传入next的下一个middleware的dispatch方法，并返\n回一个接收action的新函数，这个函数可以直接调用next\n（action），或者在其他需要的时刻调用，甚至根本不去调用它。调\n用链中最后一个middleware会接受真实的store的dispatch方\n法作为next参数，并借此结束调用链。所以，middleware的函数\n签名是（{getState，dispatch})=>next=>action。\n20.ReactHooks解决了哪些问题？\nReactHooks主要解决了以下问题：\n（1）在组件之间复用状态逻辑很难\nReact没有提供将可复用性行为“附加”到组件的途径（例如，把组\n件连接到store）解决此类问题可以使用renderprops和高阶组\n93件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会\n使代码难以理解。由providers，consumers，高阶组件，renderprops\n等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在DevTools\n过滤掉它们，但这说明了一个更深层次的问题：React需要为共享状\n态逻辑提供更好的原生途径。\n可以使用Hook从组件中提取状态逻辑，使得这些逻辑可以单独测试\n并复用。Hook使我们在无需修改组件结构的情况下复用状态逻辑。\n这使得在组件间或社区内共享Hook变得更便捷。\n（2）复杂组件变得难以理解\n在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常\n常在componentDidMount和componentDidUpdate中获取数据。但\n是，同一个componentDidMount中可能也包含很多其它的逻辑，如\n设置事件监听，而之后需在componentWillUnmount中清除。相互关\n联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同\n一个方法中组合在一起。如此很容易产生bug，并且导致逻辑不一致。\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处\n不在。这也给测试带来了一定挑战。同时，这也是很多人将React与\n状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概\n念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n为了解决这个问题，Hook将组件中相互关联的部分拆分成更小的函\n数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你\n还可以使用reducer来管理组件的内部状态，使其更加可预测。\n（3）难以理解的class\n94除了代码复用和代码管理会遇到困难外，class是学习React的一\n大屏障。我们必须去理解JavaScript中this的工作方式，这与其\n他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法\n提案，这些代码非常冗余。大家可以很好地理解props，state和自\n顶向下的数据流，但对class却一筹莫展。即便在有经验的React\n开发者之间，对于函数组件与class组件的差异也存在分歧，甚至\n还要区分两种组件的使用场景。\n为了解决这些问题，Hook使你在非class的情况下可以使用更多的\nReact特性。从概念上讲，React组件一直更像是函数。而Hook则\n拥抱了函数，同时也没有牺牲React的精神原则。Hook提供了问题\n的解决方案，无需学习复杂的函数式或响应式编程技术\n21.ReactHook的使用限制有哪些？\nReactHooks的限制主要有两条：\n不要在循环、条件或嵌套函数中调用Hook；\n在React的函数组件中调用Hook。\n那为什么会有这样的限制呢？Hooks的设计初衷是为了改进React\n组件的开发模式。在旧有的开发模式下遇到了三个问题。\n组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、\nrenderprops及状态管理框架。\n复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致\n关联部分难以拆分。\n人和机器都很容易混淆类。常见的有this的问题，但在React团\n队中还有类难以优化的问题，希望在编译优化层面做出一些改进。这\n95三个问题在一定程度上阻碍了React的后续发展，所以为了解决这\n三个问题，Hooks基于函数组件开始设计。然而第三个问题决定了\nHooks只支持函数组件。\n那为什么不要在循环、条件或嵌套函数中调用Hook呢？因为Hooks\n的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、\n条件或嵌套函数很有可能导致数组取值错位，执行错误的Hook。当\n然，实质上React的源码里不是数组，是链表。\n这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为\n了避免这样的情况，可以引入ESLint的Hooks检查插件进行预防。\n22.Reactdiff算法的原理是什么？\n实际上，diff算法探讨的就是虚拟DOM树发生变化后，生成DOM树\n更新补丁的方式。它通过对比新旧两株虚拟DOM树的变更差异，将\n更新补丁作用于真实DOM，以最小成本完成视图更新。\n具体的流程如下：\n真实的DOM首先会映射为虚拟DOM；\n当虚拟DOM发生变化后，就会根据差距计算生成patch，这个patch\n是一个结构化的数据，内容包含了增加、更新、移除等；\n根据patch去更新真实的DOM，反馈到用户的界面上。\n96\n一个简单的例子：\n这里，首先假定ExampleComponent可见，然后再改变它的状态，让\n它不可见。映射为真实的DOM操作是这样的，React会创建一个\ndiv节点。\n当把visbile的值变为false时，就会替换class属性为hidden，\n并重写内部的innerText为hidden。这样一个生成补丁、更新差异\n的过程统称为diff算法。\ndiff算法可以总结为三个策略，分别从树、组件及元素三个层面进\n行复杂度的优化：\n97策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对\n比）\n这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法\n是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发\n现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用\n于进一步的比较，这就提升了比对效率。\n策略二：如果组件的class一致，则默认为相似的树结构，否则默\n认为不同的树结构。（基于组件进行对比）\n在组件比对的过程中：\n如果组件是同一类型则进行树比对；\n如果不是则直接放入补丁中。\n只要父组件类型不同，就会被重新渲染。这也就是为什么\nshouldComponentUpdate、PureComponent及React.memo可以提高\n性能的原因。\n策略三：同一层级的子节点，可以通过标记key的方式进行列表对\n比。（基于节点进行对比）\n元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操\n作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移\n动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要\n的作用。通过标记key的方式，React可以直接移动DOM节点，降\n低内耗。\n23.Reactkey是干嘛用的为什么要加？key主要是解决哪一\n类问题的\n98Keys是React用于追踪哪些列表中元素被修改、被添加或者被移除\n的辅助标识。在开发过程中，我们需要保证某个元素的key在其同\n级元素中具有唯一性。\n在ReactDiff算法中React会借助元素的Key值来判断该元素\n是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染\n此外，React还需要借助Key值来判断元素与本地状态的关联关系。\n注意事项：\nkey值一定要和具体的元素—一对应；\n尽量不要用数组的index去作为key；\n不要在render的时候用随机数或者其他操作给元素加上不稳定的\nkey，这样造成的性能开销比不加key的情况下更糟糕。\n24.React与Vue的diff算法有何不同？\ndiff算法是指生成更新补丁的方式，主要应用于虚拟DOM树变化后，\n更新真实DOM。所以diff算法一定存在这样一个过程：触发更新→\n生成补丁→应用补丁。\nReact的diff算法，触发更新的时机主要在state变化与hooks\n调用之后。此时触发虚拟DOM树变更遍历，采用了深度优先遍历算\n法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方\n式。将单一节点比对转化为了3种类型节点的比对，分别是树、组\n件及元素，以此提升效率。\n树比对：由于网页视图中较少有跨层级节点移动，两株虚拟DOM树\n只对同一层次的节点进行比较。\n99组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接\n放入到补丁中。\n元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点\n操作对应真实的DOM剪裁操作。\n以上是经典的Reactdiff算法内容。自React16起，引入了Fiber\n架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了\nFiberNode与FiberTree进行重构。fiberNode使用了双链表的结\n构，可以直接找到兄弟节点与子节点。整个更新过程由current与\nworkInProgress两株树双缓冲完成。workInProgress更新完成后，\n再通过修改current相关指针指向新节点。\nVue的整体diff策略与React对齐，虽然缺乏时间切片能力，但\n这并不意味着Vue的性能更差，因为在Vue3初期引入过，后期因\n为收益不高移除掉了。除了高帧率动画，在Vue中其他的场景几乎\n都可以使用防抖和节流去提高响应性能。\n25.react最新版本解决了什么问题，增加了哪些东西\nReact16.x的三大新特性TimeSlicing、Suspense、hooks\nTimeSlicing（解决CPU速度问题）使得在执行任务的期间可以随时\n暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器\n跑时，仍然保持有良好的性能\nSuspense（解决网络IO问题）和lazy配合，实现异步加载组件。能\n暂停当前组件的渲染，当完成某件事以后再继续渲染，解决从react\n出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，\n使用的是T异步但是同步的写法，这是最好的解决异步问题的方式\n100提供了一个内置函数componentDidCatch，当有错误发生时，可以友\n好地展示fallback组件;可以捕捉到它的子元素（包括嵌套子元素）\n抛出的异常;可以复用错误组件。\n（1）React16.8\n加入hooks，让React函数式组件更加灵活，hooks之前，React存\n在很多问题：\n在组件间复用状态逻辑很难\n复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\nclass组件的this指向问题\n难以记忆的生命周期\nhooks很好的解决了上述问题，hooks提供了很多方法\nuseState返回有状态值，以及更新这个状态值的函数\nuseEffect接受包含命令式，可能有副作用代码的函数。\nuseContext接受上下文对象（从React.createContext返回的值）\n并返回当前上下文值，\nuseReduceruseState的替代方案。接受类型为（state，action）\n=>newState的reducer，并返回与dispatch方法配对的当前状态。\nuseCalLback返回一个回忆的memoized版本，该版本仅在其中一个\n输入发生更改时才会更改。纯函数的输入输出确定性ouseMemo纯\n的一个记忆函数ouseRef返回一个可变的ref对象，其Current属\n性被初始化为传递的参数，返回的ref对象在组件的整个生命周期\n内保持不变。\nuseImperativeMethods自定义使用ref时公开给父组件的实例值\n101useMutationEffect更新兄弟组件之前，它在React执行其DOM改变\n的同一阶段同步触发\nuseLayoutEffectDOM改变后同步触发。使用它来从DOM读取布局并\n同步重新渲染\n（2）React16.9\n重命名Unsafe的生命周期方法。新的UNSAFE_前缀将有助于在代码\nreview和debug期间，使这些有问题的字样更突出废弃\njavascrip:形式的URL。以javascript:开头的URL非常容易遭受攻\n击，造成安全漏洞。\n废弃\"Factory\"组件。工厂组件会导致React变大且变慢。\nact（）也支持异步函数，并且你可以在调用它时使用await。\n使用<React.ProfiLer>进行性能评估。在较大的应用中追踪性能回\n归可能会很方便\n（3）React16.13.0\n支持在渲染期间调用setState，但仅适用于同一组件\n可检测冲突的样式规则并记录警告\n废弃unstable_createPortal，使用CreatePortal\n将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其\n程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\n26.在React中页面重新加载时怎样保留数据？\n这个问题就设计到了数据持久化，主要的实现方式有以下几种：\n102Redux：将页面的数据存储在redux中，在重新加载页面时，获取Redux\n中的数据；\ndata.js：使用webpack构建的项目，可以建一个文件，data.js，将\n数据保存data.js中，跳转页面后获取；\nsessionStorge：在进入选择地址页面之前，componentWillUnMount\n的时候，将数据存储到sessionStorage中，每次进入页面判断\nsessionStorage中有没有存储的那个值，有，则读取渲染数据；没\n有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页\n面，清掉存储的sessionStorage，保证下次进入是初始化的数据\nhistoryAPI：HistoryAPI的pushState函数可以给历史记录关联\n一个任意的可序列化state，所以可以在路由push的时候将当前页\n面的一些信息存到state中，下次返回到这个页面的时候就能从\nstate里面取出离开前的数据重新渲染。react-router直接可以支\n持。这个方法适合一些需要临时存储的场景。\n27.为什么使用jsx的组件中没有看到使用react却需要引入\nreact？\n本质上来说JSX是React.createElement(component,\nprops,...children)方法的语法糖。在React17之前，如果使用了\nJSX，其实就是在使用React，babel会把组件转换\n为CreateElement形式。在React17之后，就不再需要引入，因\n为babel已经可以帮我们自动引入react。\n28.Redux中间件是什么？接受几个参数？柯里化函数两端的\n参数具体是什么？\n103Redux的中间件提供的是位于action被发起之后，到达reducer\n之前的扩展点，换而言之，原本view-→>action->reducer->\nstore的数据流加上中间件后变成了view->action->middleware\n->reducer->store，在这一环节可以做一些\"副作用\"的操作，如\n异步请求、打印日志等。\napplyMiddleware源码：\n从applyMiddleware中可以看出∶\nredux中间件接受一个对象作为参数，对象的参数上有两个字段\ndispatch和getState，分别代表着ReduxStore上的两个同名函\n数。\n柯里化函数两端一个是middewares，一个是store.dispatch\n29.组件通信的方式有哪些\n⽗组件向⼦组件通讯:⽗组件可以向⼦组件通过传props的⽅式，\n向⼦组件进⾏通讯\n104⼦组件向⽗组件通讯:props+回调的⽅式，⽗组件向⼦组件传递\nprops进⾏通讯，此props为作⽤域为⽗组件⾃身的函数，⼦组件\n调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的\n作⽤域中\n兄弟组件通信:找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅\n式由⽗节点转发信息进⾏通信\n跨层级通信:Context设计⽬的是为了共享那些对于⼀个组件树⽽\n⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于\n跨越多层的全局数据通过Context通信再适合不过\n发布订阅模式:发布者发布事件，订阅者监听事件并做出反应,我们\n可以通过引⼊event模块进⾏通信\n全局状态管理⼯具:借助Redux或者Mobx等全局状态管理⼯具进⾏\n通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产\n⽣新的状态\n性能优化部分\n1.懒加载的概念\n懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片\n数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，\n如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口\n的那一部分图片数据，这样就浪费了性能。\n如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视\n化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网\n105页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，\n页面列表较长（长列表）的场景中。\n2.懒加载的特点\n减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，\n同时也减小了浏览器的负担。\n提升用户体验:如果同时加载较多图片，可能需要等待的时间较长，\n这样影响了用户体验，而使用懒加载就能大大的提高用户体验。\n防止加载过多图片而影响其他资源文件的加载：会影响网站应用的\n正常使用。\n3.懒加载的实现原理\n图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片\n资源。根据这个原理，我们使用HTML5的data-xxx属性来储存图片\n的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给\nsrc，这样就实现了图片的按需加载，即懒加载。\n注意：data-xxx中的xxx可以自定义，这里我们使用data-src来定\n义。\n懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可\n视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，\n获取图片的真实地址并赋值给图片即可。\n使用原生JavaScript实现懒加载：\n知识点：\nwindow.innerHeight是浏览器可视区的高度\ndocument.body.scrollTop\n106document.documentElement.scrollTop是浏览器滚动的过的距离\nimgs.offsetTop是元素顶部距离文档顶部的高度（包括滚动条的距\n离）\n图片加载条件：img.offsetTop<window.innerHeight+\ndocument.body.scrollTop;\n图示：\n代码实现：\n107\n4.回流与重绘的概念及触发条件\n（1）回流\n当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏\n览器会重新渲染部分或者全部文档的过程就称为回流。\n下面这些操作会导致回流：\n页面的首次渲染\n浏览器的窗口大小发生变化\n元素的内容发生变化\n元素的尺寸或者位置发生变化\n元素的字体大小发生变化\n激活CSS伪类\n查询某些属性或者调用某些方法\n添加或者删除可见的DOM元素\n108在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，\n所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围\n有两种：\n全局范围：从根节点开始，对整个渲染树进行重新布局\n局部范围：对渲染树的某部分或者一个渲染对象进行重新布局\n（2）重绘\n当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位\n置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。\n下面这些操作会导致重绘：\ncolor、background相关属性：background-color、background-image\n等\noutline相关属性：outline-color、outline-width、\ntext-decoration\nborder-radius、visibility、box-shadow\n注意：当触发回流时，一定会触发重绘，但是重绘不一定会引发回\n流。\n5.如何避免回流与重绘？\n减少回流与重绘的措施：\n操作DOM时，尽量在低层级的DOM节点进行操作\n不要使用table布局，一个小的改动可能会使整个table进行重新\n布局\n使用CSS的表达式\n109不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样\n式。\n使用absolute或者fixed，使元素脱离文档流，这样他们发生变化\n就不会影响其他元素\n避免频繁操作DOM，可以创建一个文档片段documentFragment，在它\n上面应用所有DOM操作，最后再把它添加到文档中\n将元素先设置display:none，操作结束后再把它显示出来。因为在\ndisplay属性为none的元素上进行的DOM操作不会引发回流和重绘。\n将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插\n着写。这得益于浏览器的渲染队列机制。\n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操\n作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行\n批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作\n进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发\n一次回流。\n6.如何优化动画？\n对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作\nDOM，就就会导致页面的性能问题，我们可以将动画的position属性\n设置为absolute或者fixed，将动画脱离文档流，这样他的回流就\n不会影响到页面了。\n1107.documentFragment是什么？用它跟直接操作DOM的区别是\n什么？\nMDN中对documentFragment的解释：\nDocumentFragment，文档片段接口，一个没有父对象的最小文档对象。\n它被作为一个轻量版的Document使用，就像标准的document一样，\n存储由节点（nodes）组成的文档结构。与document相比，最大的区\n别是DocumentFragment不是真实DOM树的一部分，它的变化不会触\n发DOM树的重新渲染，且不会导致性能等问题。\n当我们把一个DocumentFragment节点插入文档树时，插入的不是\nDocumentFragment自身，而是它的所有子孙节点。在频繁的DOM操\n作时，我们就可以将DOM元素插入DocumentFragment，之后一次性\n的将所有的子孙节点插入文档中。和直接操作DOM相比，将\nDocumentFragment节点插入DOM树时，不会触发页面的重绘，这样\n就大大提高了页面的性能。\n8.对节流与防抖的理解\n函数防抖是指在事件被触发n秒后再执行回调，如果在这n秒内事\n件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避\n免因为用户的多次点击向后端发送多次请求。\n函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触\n发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，\n只有一次能生效。节流可以使用在scroll函数的事件监听上，通过\n事件节流来降低事件调用的频率。\n防抖函数的应用场景：\n111按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次\n服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊\n事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤\nlodash.debounce\n节流函数的适⽤场景：\n拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动\n缩放场景：监控浏览器resize\n动画场景：避免短时间内多次触发动画引起性能问题\n9.实现节流函数和防抖函数\n函数防抖的实现：\n函数节流的实现：\n112\n10.如何对项目中的图片进行优化？\n1.不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片\n完全可以用CSS去代替。\n2.对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪\n费带宽。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然\n后去请求相应裁剪好的图片。\n3.小图使用base64格式\n4.将多个图标文件整合到一张图片中（雪碧图）\n5.选择正确的图片格式：\n113对于能够显示WebP格式的浏览器尽量使用WebP格式。因为WebP\n格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥\n有肉眼识别无差异的图像质量，缺点就是兼容性并不好\n小图使用PNG，其实对于大部分图标这类图片，完全可以使用SVG代\n替\n照片使用JPEG\n11.常见的图片格式及使用场景\n（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图\n片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的\n文件。\n（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行\n编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画\n以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格\n式适用于对色彩要求不高同时需要文件体积较小的场景。\n（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采\n用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，\n与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有\n损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF\n更大。\n（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图\n片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该\n尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8\n具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF\n并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。\n114（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它\n压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小\n要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8\n大得多。\n（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲\n线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲\n线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所\n以它非常适合用来绘制Logo、Icon等。\n（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无\n损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而\n生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更\n小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个\n图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，\n进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera\n浏览器支持WebP格式，兼容性不太好。\n在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小\n26%；\n在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要\n比JPEG小25%~34%；\nWebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要\n支持透明度只需要22%的格外文件大小。\n12.如何⽤webpack来优化前端性能？\n⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最\n终结果在浏览器运⾏快速⾼效。\n115压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以\n利⽤webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩\nJS⽂件，利⽤cssnano（css-loader?minimize）来压缩css\n利⽤CDN加速:在构建过程中，将引⽤的静态资源路径修改为CDN上\n对应的路径。可以利⽤webpack对于output参数和各loader的\npublicPath参数来修改资源路径\nTreeShaking:将代码中永远不会⾛到的⽚段删除掉。可以通过在启\n动webpack时追加参数--optimize-minimize来实现\nCodeSplitting:将代码按路由维度或者组件分块(chunk),这样做\n到按需加载,同时可以充分利⽤浏览器缓存\n提取公共第三⽅库:SplitChunksPlugin插件来进⾏公共模块抽取,\n利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码\n13.如何提⾼webpack的构建速度？\n1.多⼊⼝情况下，使⽤CommonsChunkPlugin来提取公共代码\n2.通过externals配置来提取常⽤库\n3.利⽤DllPlugin和DllReferencePlugin预编译资源模块通过\nDllPlugin来对那些我们引⽤但是绝对不会修改的npm包来进⾏预\n编译，再通过DllReferencePlugin将预编译的模块加载进来。\n4.使⽤Happypack实现多线程加速编译\n5.使⽤webpack-uglify-parallel来提升uglifyPlugin的压缩速\n度。原理上webpack-uglify-parallel采⽤了多核并⾏压缩来提升\n压缩速度\n6.使⽤Tree-shaking和ScopeHoisting来剔除多余代码\n116前端工程化部分\n1.webpack与grunt、gulp的不同？\nGrunt、Gulp是基于任务运⾏的⼯具：它们会⾃动执⾏指定的任务，\n就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活\n跃的社区，丰富的插件，能⽅便的打造各种⼯作流。\nWebpack是基于模块化打包的⼯具:⾃动化处理模块，webpack把⼀\n切当成模块，当webpack处理应⽤程序时，它会递归地构建⼀个依\n赖关系图(dependencygraph)，其中包含应⽤程序需要的每个模块，\n然后将所有这些模块打包成⼀个或多个bundle。\n因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤npmscript代\n替Grunt、Gulp，npmscript同样可以打造任务流。\n2.webpack、rollup、parcel优劣？\nwebpack适⽤于⼤型复杂的前端站点构建:webpack有强⼤的loader\n和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即\n执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，\n值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块\n等,这种情况更适合⽂件依赖复杂的应⽤开发。\nrollup适⽤于基础库的打包，如vue、d3等:Rollup就是将各个模\n块打包进⼀个⽂件中，并且通过Tree-shaking来删除⽆⽤的代码,\n可以最⼤程度上降低代码体积,但是rollup没有webpack如此多的的\n如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适\n合库的开发。\n117parcel适⽤于简单的实验性项⽬:他可以满⾜低⻔槛的快速看到效\n果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项\n⽬或者实验项⽬不建议使⽤。\n3.有哪些常⻅的Loader？\nfile-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对URL\n去引⽤输出的⽂件\nurl-loader：和file-loader类似，但是能在⽂件很⼩的情况下以\nbase64的⽅式把⽂件内容注⼊到代码中去\nsource-map-loader：加载额外的SourceMap⽂件，以⽅便断点调\n试\nimage-loader：加载并且压缩图⽚⽂件\nbabel-loader：把ES6转换成ES5\ncss-loader：加载CSS，⽀持模块化、压缩、⽂件导⼊等特性\nstyle-loader：把CSS代码注⼊到JavaScript中，通过DOM操作\n去加载CSS。\neslint-loader：通过ESLint检查JavaScript代码\n注意：在Webpack中，loader的执行顺序是从右向左执行的。因为\nwebpack选择了compose这样的函数式编程方式，这种方式的表达式\n执行是从右向左的。\n4.有哪些常⻅的Plugin？\ndefine-plugin：定义环境变量\nhtml-webpack-plugin：简化html⽂件创建\n118uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码\nwebpack-parallel-uglify-plugin:多核压缩，提⾼压缩速度\nwebpack-bundle-analyzer:可视化webpack输出⽂件的体积\nmini-css-extract-plugin:CSS提取到单独的⽂件中，⽀持按需加\n载\n5.bundle，chunk，module是什么？\nbundle：是由webpack打包出来的⽂件；\nchunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并\n和分割；\nmodule：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀\n个模块对应⼀个⽂件，webpack会从配置的entry中递归开始找出所\n有依赖的模块。\n6.Loader和Plugin的不同？\n不同的作⽤:\nLoader直译为\"加载器\"。Webpack将⼀切⽂件视为模块，但是webpack\n原⽣是只能解析js⽂件，如果想将其他⽂件也打包的话，就会⽤到\nloader。所以Loader的作⽤是让webpack拥有了加载和解析⾮\nJavaScript⽂件的能⼒。\nPlugin直译为\"插件\"。Plugin可以扩展webpack的功能，让webpack\n具有更多的灵活性。在Webpack运⾏的⽣命周期中会⼴播出许多事\n件，Plugin可以监听这些事件，在合适的时机通过Webpack提供的\nAPI改变输出结果。\n不同的⽤法:\n119Loader在module.rules中配置，也就是说他作为模块的解析规则\n⽽存在。类型为数组，每⼀项都是⼀个Object，⾥⾯描述了对于\n什么类型的⽂件（test），使⽤什么加载(loader)和使⽤的参数\n（options）\nPlugin在plugins中单独配置。类型为数组，每⼀项是⼀个plugin\n的实例，参数都通过构造函数传⼊。\n7.webpack热更新的实现原理？\nwebpack的热更新⼜称热替换（HotModuleReplacement），缩写为\nHMR。这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧\n的模块。\n原理：\n120⾸先要知道server端和client端都做了处理⼯作：\n第⼀步，在webpack的watch模式下，⽂件系统中某⼀个⽂件发⽣\n修改，webpack监听到⽂件变化，根据配置⽂\n件对模块重新编译打包，并将打包后的代码通过简单的JavaScript\n对象保存在内存中。\n第⼆步是webpack-dev-server和webpack之间的接⼝交互，⽽在\n这⼀步，主要是dev-server的中间件webpack-dev-middleware\n和webpack之间的交互，webpack-dev-middleware调⽤webpack\n暴露的API对代码变化进⾏监控，并且告诉webpack，将代码打包\n到内存中。\n第三步是webpack-dev-server对⽂件变化的⼀个监控，这⼀步不同\n于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置\n了devServer.watchContentBase为true的时候，Server会监听\n这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进\n⾏livereload。注意，这⼉是浏览器刷新，和HMR是两个概念。\n第四步也是webpack-dev-server代码的⼯作，该步骤主要是通过\nsockjs（webpack-dev-server的依赖）在浏览器端和服务端之间建\n⽴⼀个websocket⻓连接，将webpack编译打包的各个阶段的状态\n信息告知浏览器端，同时也包括第三步中Server监听静态⽂件变化\n的信息。浏览器端根据这些socket消息进⾏不同的操作。当然服务\n端传递的最主要信息还是新模块的hash值，后⾯的步骤根据这⼀\nhash值来进⾏模块热替换。\nwebpack-dev-server/client端并不能够请求更新的代码，也不会执\n⾏热更模块操作，⽽把这些⼯作⼜交回给了webpack，\n121webpack/hot/dev-server的⼯作就是根据\nwebpack-dev-server/client传给它的信息以及dev-server的配\n置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏\n览器，也就没有后⾯那些步骤了。\nHotModuleReplacement.runtime是客户端HMR的中枢，它接收到上\n⼀步传递给他的新模块的hash值，它通过\nJsonpMainTemplate.runtime向server端发送Ajax请求，服务端\n返回⼀个json，该json包含了所有要更新的模块的hash值，获\n取到更新列表后，该模块再次通过jsonp请求，获取到最新的模块\n代码。这就是上图中7、8、9步骤。\n⽽第10步是决定HMR成功与否的关键步骤，在该步骤中，\nHotModulePlugin将会对新旧模块进⾏对⽐，决定是否更新模块，在\n决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模\n块间的依赖引⽤。\n最后⼀步，当HMR失败后，回退到livereload操作，也就是进⾏\n浏览器刷新来获取最新打包代码。\n8.Babel的原理是什么?\nbabel的转译过程也分为三个阶段，这三步具体是：\n解析Parse:将代码解析⽣成抽象语法树（AST），即词法分析与语\n法分析的过程；\n转换Transform:对于AST进⾏变换⼀系列的操作，babel接受得\n到AST并通过babel-traverse对其进⾏遍历，在此过程中进⾏添\n加、更新及移除等操作；\n122⽣成Generate:将变换后的AST再转换为JS代码,使⽤到的模\n块是babel-generator。\n9.git和svn的区别\ngit和svn最大的区别在于git是分布式的，而svn是集中式的。\n因此我们不能再离线的情况下使用svn。如果服务器出现问题，就没\n有办法使用svn来提交代码。\nsvn中的分支是整个版本库的复制的一份完整目录，而git的分支\n是指针指向某次提交，因此git的分支创建更加开销更小并且分支\n上的变化不会影响到其他人。svn的分支变化会影响到所有的人。\nsvn的指令相对于git来说要简单一些，比git更容易上手。\nGIT把内容按元数据方式存储，而SVN是按文件：因为git目录是处\n于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东\n西，例如标签，分支，版本记录等。\nGIT分支和SVN的分支不同：svn会发生分支遗漏的情况，而git可\n以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并\n的分支，简单而快捷的合并这些文件。\nGIT没有一个全局的版本号，而SVN有\n123GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希\n算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题\n时降低对版本库的破坏\n10.经常使用的git命令？\n11.gitpull和gitfetch的区别\ngitfetch只是将远程仓库的变化下载下来，并没有和本地分支合并。\ngitpull会将远程仓库的变化下载下来，并和当前分支合并。\n12.gitrebase和gitmerge的区别\ngitmerge和gitrebase都是用于分支合并，关键在commit记录\n的处理上不同：\ngitmerge会新建一个新的commit对象，然后两个分支以前的\ncommit记录都指向这个新commit记录。这种方法会保留之前每个\n分支的commit历史。\ngitrebase会先找到两个分支的第一个共同的commit祖先记录，\n然后将提取当前分支这之后的所有commit记录，然后将这个\ncommit记录添加到目标分支的最新提交后面。经过这个合并后，两\n个分支合并后的commit记录就变为了线性的记录了。\n浏览器部分\n1.什么是XSS攻击？\n124（1）概念\nXSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在\n网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信\n息如cookie等。\nXSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合\n在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意\n代码的执行。\n攻击者可以通过这种攻击方式可以进行以下操作：\n获取页面的数据，如DOM、cookie、localStorage；\nDOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服\n务器；\n破坏页面结构；\n流量劫持（将链接指向某网站）；\n（2）攻击类型\nXSS可以分为存储型、反射型和DOM型：\n存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，\n脚本从服务器传回并执行。\n反射型指的是攻击者诱导用户访问一个带有恶意代码的URL后，服\n务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，\n浏览器端解析这段带有XSS代码的数据后当做脚本执行，最终完成\nXSS攻击。\nDOM型指的通过修改页面的DOM节点形成的XSS。\n1）存储型XSS的攻击步骤：\n1251.攻击者将恶意代码提交到⽬标⽹站的数据库中。\n2.⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接\n在HTML中返回给浏览器。\n3.⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n4.恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏\n为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评\n论、⽤户私信等。\n2）反射型XSS的攻击步骤：\n1.攻击者构造出特殊的URL，其中包含恶意代码。\n2.⽤户打开带有恶意代码的URL时，⽹站服务端将恶意代码从URL\n中取出，拼接在HTML中返回给浏览器。\n3.⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。\n4.恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏\n为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n反射型XSS跟存储型XSS的区别是：存储型XSS的恶意代码存在\n数据库⾥，反射型XSS的恶意代码存在URL⾥。\n反射型XSS漏洞常⻅于通过URL传递参数的功能，如⽹站搜索、跳\n转等。由于需要⽤户主动打开恶意的URL才能⽣效，攻击者往往会\n结合多种⼿段诱导⽤户点击。\n3）DOM型XSS的攻击步骤：\n1.攻击者构造出特殊的URL，其中包含恶意代码。\n1262.⽤户打开带有恶意代码的URL。\n3.⽤户浏览器接收到响应后解析执⾏，前端JavaScript取出URL\n中的恶意代码并执⾏。\n4.恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏\n为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\nDOM型XSS跟前两种XSS的区别：DOM型XSS攻击中，取出和执\n⾏恶意代码由浏览器端完成，属于前端JavaScript⾃身的安全漏洞，\n⽽其他两种XSS都属于服务端的安全漏洞。\n2.如何防御XSS攻击？\n可以看到XSS危害如此之大，那么在开发网站时就要做好防御措施，\n具体措施如下：\n可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服\n务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到\nHTML中的代码做好充分的转义。对于DOM型的攻击，主要是前端脚\n本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对\n可能出现的恶意代码情况进行判断。\n使用CSP，CSP的本质是建立一个白名单，告诉浏览器哪些外部资\n源可以加载和执行，从而防止恶意代码的注入攻击。\n1.CSP指的是内容安全策略，它的本质是建立一个白名单，告诉浏览\n器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由\n浏览器自己来实现。\n1272.通常有两种方式来开启CSP，一种是设置HTTP首部中的\nContent-Security-Policy，一种是设置meta标签的方式<meta\nhttp-equiv=\"Content-Security-Policy\">\n对一些敏感信息进行保护，比如cookie使用http-only，使得脚本\n无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。\n3.什么是CSRF攻击？\n（1）概念\nCSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三\n方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击\n网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过\n后台的用户验证，冒充用户向服务器执行一些操作。\nCSRF攻击的本质是利用cookie会在同源请求中携带发送给服务器\n的特点，以此来实现用户的冒充。\n（2）攻击类型\n常见的CSRF攻击有三种：\nGET类型的CSRF攻击，比如在网站中的一个img标签里构建一个\n请求，当用户打开这个网站的时候就会自动发起提交。\nPOST类型的CSRF攻击，比如构建一个表单，然后隐藏它，当用户\n进入页面时，自动提交这个表单。\n链接类型的CSRF攻击，比如在a标签的href属性里构建一个请\n求，然后诱导用户去点击。\n4.如何防御CSRF攻击？\nCSRF攻击可以使用以下方法来防护：\n128进行同源检测，服务器根据http请求头中origin或者referer\n信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当\norigin或者referer信息都不存在的时候，直接阻止请求。这种方\n式的缺点是有些情况下referer可以被伪造，同时还会把搜索引擎\n的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是\n相应的页面请求这种请求方式也可能被攻击者给利用。（Referer字\n段会告诉服务器该网页是从哪个页面链接过来的）\n使用CSRFToken进行验证，服务器向用户返回一个随机数Token，\n当网站再次发起请求时，在请求参数中加入服务器端返回的token，\n然后服务器对这个token进行验证。这种方法解决了使用cookie\n单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点\n就是，我们需要给网站中的所有请求都添加上这个token，操作比较\n繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过\n负载平衡转移到了其他的服务器，但是这个服务器的session中没\n有保留这个token的话，就没有办法验证了。这种情况可以通过改\n变token的构建方式来解决。\n对Cookie进行双重验证，服务器在用户访问网站页面时，向请求域\n名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器\n发送请求的时候，从cookie中取出这个字符串，添加到URL参数\n中，然后服务器通过对cookie中的数据和参数中的数据进行比较，\n来进行验证。使用这种方式是利用了攻击者只能利用cookie，但是\n不能访问获取cookie的特点。并且这种方法比CSRFToken的方法\n更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果\n网站存在XSS漏洞的，那么这种方式会失效。同时这种方式不能做\n到子域名的隔离。\n129在设置cookie属性的时候设置Samesite，限制cookie不能作为\n被第三方使用，从而可以避免被攻击者利用。Samesite一共有两种\n模式，一种是严格模式，在严格模式下cookie在任何情况下都不可\n能作为第三方Cookie使用，在宽松模式下，cookie可以被请求是\nGET请求，且会发生页面跳转的请求所使用。\n5.有哪些可能引起前端安全的问题?\n跨站脚本(Cross-SiteScripting,XSS):⼀种代码注⼊⽅式,为了\n与CSS区分所以被称作XSS。早期常⻅于⽹络论坛,起因是⽹站没\n有对⽤户的输⼊进⾏严格的限制,使得攻击者可以将脚本上传到帖\n⼦让其他⼈浏览到有恶意脚本的⻚⾯,其注⼊⽅式很简单包括但不\n限于JavaScript/CSS/Flash等；\niframe的滥⽤:iframe中的内容是由第三⽅来提供的，默认情况下\n他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash\n插件、弹出对话框等等，这可能会破坏前端⽤户体验；\n跨站点请求伪造（Cross-SiteRequestForgeries，CSRF）:指攻击\n者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信\n息或设定信息等某些状态更新，属于被动攻击\n恶意第三⽅库:⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数\n时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被\n植⼊恶意代码很容易引起安全问题。\n6.网络劫持有哪几种，如何防范？\n⽹络劫持分为两种:\n（1）DNS劫持:(输⼊京东被强制跳转到淘宝这就属于dns劫持)\n130DNS强制解析:通过修改运营商的本地DNS记录，来引导⽤户流量到\n缓存服务器\n302跳转的⽅式:通过监控⽹络出⼝的流量，分析判断哪些内容是可\n以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户\n获取内容\n（2）HTTP劫持:(访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http\n明⽂传输,运营商会修改你的http响应内容(即加⼴告)\n（3）DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS\n劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将\nHTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。\n7.浏览器渲染进程的线程有哪些\n浏览器的渲染进程的线程总共有五种：\n（1）GUI渲染线程\n131负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、\n构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，\n该线程就会执行。\n注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI\n线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时\n立即被执行。\n（2）JS引擎线程\nJS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析\nJavascript脚本，运行代码；JS引擎线程一直等待着任务队列中任\n务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个\nJS引擎线程在运行JS程序；\n注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的\n时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n（3）时间触发线程\n时间触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS\n引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线\n程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发\n线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加\n到待处理队列的队尾，等待JS引擎的处理；\n注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排\n队等待JS引擎处理（当JS引擎空闲时才会去执行）；\n（4）定时器触发进程\n132定时器触发进程即setInterval与setTimeout所在线程；浏览器定\n时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处\n于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时\n并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲\n后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，\n定时器只是在指定时间点将任务添加到事件队列中；\n注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如\n果是小于4ms，则默认为4ms。\n（5）异步http请求线程\nXMLHttpRequest连接后通过浏览器新开一个线程请求；\n检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更\n事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；\n8.僵尸进程和孤儿进程是什么？\n孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些\n子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所\n收养，并由init进程对它们完成状态收集工作。\n僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用\n的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之\n为僵死进程。\n9.如何实现浏览器内多个标签页之间的通信?\n实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。\n因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让\n133标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通\n信方法如下：\n使用websocket协议，因为websocket协议可以实现服务器推送，\n所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数\n据，然后由服务器向其他标签页推送转发。\n使用ShareWorker的方式，shareWorker会在页面存在的生命周期\n内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。\n这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个\n线程，然后通过这个共享的线程来实现数据的交换。\n使用localStorage的方式，我们可以在一个标签页对localStorage\n的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就\n可以通过这个监听事件来获取到数据。这个时候localStorage对象\n就是充当的中介者的角色。\n使用postMessage方法，如果我们能够获得对应标签页的引用，就\n可以使用postMessage方法，进行通信。\n10.对浏览器的缓存机制的理解\n浏览器缓存的全过程：\n浏览器第一次加载资源，服务器返回200，浏览器从服务器下载资源\n文件，并缓存资源文件与responseheader，以供下次加载时对比使\n用；\n下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上\n一次返回200时的时间差，如果没有超过cache-control设置的\nmax-age，则没有过期，并命中强缓存，直接从本地读取资源。如果\n浏览器不支持HTTP1.1，则使用expires头判断是否过期；\n134如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向\n服务器发送带有If-None-Match和If-Modified-Since的请求；\n服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做\n修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不\n一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；\n如果服务器收到的请求没有Etag值，则将If-Modified-Since和\n被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；\n不一致则返回新的last-modified和文件并返回200；\n很多网站的资源后面都加了版本号，这样做的目的是：每次升级了JS\n或CSS文件后，为了防止浏览器进行缓存，强制改变版本号，客户\n端浏览器就会重新下载新的JS或CSS文件，以保证用户能够及时\n获得网站的最新更新。\n11.协商缓存和强缓存的区别\n135（1）强缓存\n使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必\n再向服务器发起请求。\n强缓存策略可以通过两种方式来设置，分别是http头信息中的\nExpires属性和Cache-Control属性\n（1）服务器通过在响应头中添加Expires属性，来指定资源的过期\n时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发\n送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存\n在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用\n户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的\n结果。\n（2）Expires是http1.0中的方式，因为它的一些缺点，在HTTP\n1.1中提出了一个新的头部属性就是Cache-Control属性，它提供\n了对资源的缓存的更精确的控制。它有很多不同的值，\nCache-Control可设置的字段：\npublic：设置了该字段值的资源表示可以被任何对象（包括：发送请\n求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是\n使用max-age=来精确控制；\nprivate：设置了该字段值的资源只能被用户浏览器缓存，不允许任\n何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，\n通常都要设置这个字段值，避免代理服务器(CDN)缓存；\nno-cache：设置了该字段需要先和服务端确认返回的资源是否发生了\n变化，如果资源未发生变化，则直接使用缓存好的资源；\n136no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起\n新的请求，拉取最新的资源；\nmax-age=：设置缓存的最大有效期，单位为秒；\ns-maxage=：优先级高于max-age=，仅适用于共享缓存(CDN)，优先\n级高于max-age或者Expires头；\nmax-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，\n但是不能超过给定的时间限制。\n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方\n式一起使用时，Cache-Control的优先级要高于Expires。\nno-cache和no-store很容易混淆：\nno-cache是指先要和服务器确认是否有资源更新，在进行判断。也\n就是说没有强缓存，但是会有协商缓存；\nno-store是指不使用任何缓存，每次请求都直接从服务器获取资源。\n（2）协商缓存\n如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如\n果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会\n发挥作用了。\n上面已经说到了，命中协商缓存的条件有两个：\nmax-age=xxx过期了\n值为no-store\n使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发\n生修改，则返回一个304状态，让浏览器使用本地的缓存副本。如\n果资源发生了修改，则返回修改后的资源。\n137协商缓存也可以通过两种方式来设置，分别是http头信息中的\nEtag和Last-Modified属性。\n（1）服务器通过在响应头中添加Last-Modified属性来指出资源最\n后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加\n一个If-Modified-Since的属性，属性值为上一次资源返回时的\nLast-Modified的值。当请求发送到服务器后服务器会通过这个属性\n来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做\n了修改。如果资源没有修改，那么返回304状态，让客户端使用本\n地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种\n方法有一个缺点，就是Last-Modified标注的最后修改时间只能精\n确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件\n已将改变了但是Last-Modified却没有改变，这样会造成缓存命中\n的不准确。\n（2）因为Last-Modified的这种可能发生的不准确性，http中提\n供了另外一种方式，那就是Etag属性。服务器在返回资源的时候，\n在头信息中添加了Etag属性，这个属性是资源生成的唯一标识符，\n当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，\n浏览器会在请求头中添加一个If-None-Match属性，这个属性的值\n就是上次返回的资源的Etag的值。服务接收到请求后会根据这个值\n来和资源当前的Etag的值来进行比较，以此来判断资源是否发生改\n变，是否需要返回资源。通过这种方式，比Last-Modified的方式\n更加精确。\n当Last-Modified和Etag属性同时出现的时候，Etag的优先级更\n高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多\n个服务器上资源的Last-Modified应该保持一致，因为每个服务器\n138上Etag的值都不一样，因此在考虑负载平衡时，最好不要设置Etag\n属性。\n总结：\n强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存\n副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命\n中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强\n缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求\n的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命\n中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命\n中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如\n果协商缓存不命中，则浏览器返回最新的资源给浏览器。\n12.点击刷新按钮或者按F5、按Ctrl+F5（强制刷新）、地址\n栏回车有什么区别？\n点击刷新按钮或者按F5：浏览器直接对本地的缓存文件过期，但是\n会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对\n文件检查新鲜度，返回结果可能是304，也有可能是200。\n用户按Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且\n不会带上If-Modifed-Since，If-None-Match，相当于之前从来没有\n请求过，返回结果是200。\n地址栏回车：浏览器发起请求，按照正常流程，本地检查是否过期，\n然后服务器检查新鲜度，最后返回内容。\n13.常见的浏览器内核比较\n139Trident：这种浏览器内核是IE浏览器用的内核，因为在早期IE占\n有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根\n据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准\n支持不是很好。但是由于IE的高市场占有率，微软也很长时间没有\n更新Trident内核，就导致了Trident内核和W3C标准脱节。还\n有就是Trident内核的大量Bug等安全问题没有得到解决，加上一\n些专家学者公开自己认为IE浏览器不安全的观点，使很多用户开始\n转向其他浏览器。\nGecko：这是Firefox和Flock所采用的内核，这个内核的优点就\n是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，\n但是代价是也显而易见就是要消耗很多的资源，比如内存。\nPresto：Opera曾经采用的就是Presto内核，Presto内核被称为\n公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，\n在处理JS脚本等脚本语言时，会比其他的内核快3倍左右，缺点就\n是为了达到很快的速度而丢掉了一部分网页兼容性。\nWebkit：Webkit是Safari采用的内核，它的优点就是网页浏览速\n度较快，虽然不及Presto但是也胜于Gecko和Trident，缺点是\n对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会\n使一些编写不标准的网页无法正确显示。WebKit前身是KDE小组的\nKHTML引擎，可以说WebKit是KHTML的一个开源的分支。\nBlink：谷歌在ChromiumBlog上发表博客，称将与苹果的开源浏览\n器核心Webkit分道扬镳，在Chromium项目中研发Blink渲染引\n擎（即浏览器核心），内置于Chrome浏览器之中。其实Blink引\n擎就是Webkit的一个分支，就像webkit是KHTML的分支一样。\nBlink引擎现在是谷歌公司与OperaSoftware共同研发，上面提到\n140过的，Opera弃用了自己的Presto内核，加入Google阵营，跟随\n谷歌一起研发Blink。\n14.浏览器的渲染过程\n浏览器渲染主要有以下步骤：\n首先解析收到的文档，根据文档定义构建一棵DOM树，DOM树是由\nDOM元素及属性节点组成的。\n然后对CSS进行解析，生成CSSOM规则树。\n根据DOM树和CSSOM规则树构建渲染树。渲染树的节点被称为渲染\n对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和\nDOM元素相对应，但这种对应关系不是一对一的，不可见的DOM元\n素不会被插入渲染树。还有一些DOM元素对应几个可见对象，它们\n一般是一些具有复杂结构的元素，无法用一个矩形来描述。\n当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏\n览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。\n这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位\n置和大小。通常这一行为也被称为“自动重排”。\n布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的paint\n方法将它们的内容显示在屏幕上，绘制使用UI基础组件。\n大致过程如图所示：\n141\n注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会\n尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完\n成之后再去构建和布局render树。它是解析完一部分内容就显示一\n部分内容，同时，可能还在通过网络下载其余内容。\n15.渲染过程中遇到JS文件如何处理？\nJavaScript的加载、解析与执行会阻塞文档的解析，也就是说，在\n构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停文\n档的解析，将控制权移交给JavaScript引擎，等JavaScript引擎\n运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如\n果想要首屏渲染的越快，就越不应该在首屏就加载JS文件，这也是\n都建议将script标签放在body标签底部的原因。当然在当下，并\n不是说script标签必须放在底部，因为你可以给script标签添加\ndefer或者async属性。\n16.前端储存的⽅式有哪些？\ncookies：在HTML5标准前本地储存的主要⽅式，优点是兼容性好，\n请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie\n142浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃\n⾏封装；\nlocalStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，\n优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容\nIE8+；\nsessionStorage：与localStorage基本类似，区别是sessionStorage\n当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不\n能在所有同源窗⼝中共享，是会话级别的储存⽅式；\nWebSQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流\n浏览器（⽕狐除外）都已经有了相关的实现，websql类似于SQLite，\n是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript\n时要进⾏转换，较为繁琐；\nIndexedDB：是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL\n数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web\n场景，同时⽤JavaScript进⾏操作会⾮常便。\n17.事件是什么？事件模型？\n事件是用户操作网页时发生的交互动作，比如click/move，事件除\n了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事\n件被封装成一个event对象，包含了该事件发生时的所有相关信息\n（event的属性）以及可以对事件进行的操作（event的方法）。\n事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现\n代浏览器一共有三种事件模型：\nDOM0级事件模型，这种模型不会传播，所以没有事件流的概念，但\n是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义\n143监听函数，也可以通过js属性来指定监听函数。所有浏览器都兼容\n这种方式。直接在dom对象上注册事件名称，就是DOM0写法。\nIE事件模型，在该事件模型中，一次事件共有两个过程，事件处理\n阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听\n事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到\ndocument，依次检查经过的节点是否绑定了事件监听函数，如果有则\n执行。这种模型通过attachEvent来添加监听函数，可以添加多个\n监听函数，会按顺序依次执行。\nDOM2级事件模型，在该事件模型中，一次事件共有三个过程，第一\n个过程是事件捕获阶段。捕获指的是事件从document一直向下传播\n到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有\n则执行。后面两个阶段和IE事件模型的两个阶段相同。这种事件模\n型，事件绑定的函数是addEventListener，其中第三个参数可以指\n定事件是否在捕获阶段执行。\n18.对事件循环的理解\n因为js是单线程运行的，在代码执行时，通过将不同函数的执行上\n下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果\n遇到异步事件，js引擎并不会一直等待其返回结果，而是会将这个\n事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，\n再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列\n可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕\n后，js引擎首先会判断微任务队列中是否有任务可以执行，如果有\n就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行\n完成后再去执行宏任务队列中的任务。\n144\nEventLoop执行顺序如下所示：\n首先执行同步代码，这属于宏任务\n当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执\n行\n执行所有微任务\n当执行完所有微任务后，如有必要会渲染页面\n然后开始下一轮EventLoop，执行宏任务中的异步代码\n计算机网络部分\n1.GET和POST的请求的区别\nPost和Get是HTTP请求的两种方法，其区别如下：\n应用场景：GET请求是一个幂等的请求，一般Get请求用于对服务\n器资源不会产生影响的场景，比如说请求一个网页的资源。而Post\n不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比\n如注册用户这一类的操作。\n是否缓存：因为两者应用场景不同，浏览器一般会对Get请求缓存，\n但很少对Post请求缓存。\n145发送的报文格式：Get请求的报文中实体部分为空，Post请求的报\n文中实体部分一般为向服务器发送的数据。\n安全性：Get请求可以将请求的参数放入url中向服务器发送，这\n样的做法相对于Post请求来说是不太安全的，因为请求的url会\n被保留在历史记录中。\n请求长度：浏览器由于对url长度的限制，所以会影响get请求发\n送数据时的长度。这个限制是浏览器规定的，并不是RFC规定的。\n参数类型：post的参数传递支持更多的数据类型。\n2.POST和PUT请求的区别\nPUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增\n加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有\n不同。（可以理解为时更新数据）\nPOST请求是向服务器端发送数据，该请求会改变数据的种类等资源，\n它会创建新的内容。（可以理解为是创建数据）\n3.常见的HTTP请求头和响应头\nHTTPRequestHeader常见的请求头：\nAccept:浏览器能够处理的内容类型\nAccept-Charset:浏览器能够显示的字符集\nAccept-Encoding：浏览器能够处理的压缩编码\nAccept-Language：浏览器当前设置的语言\nConnection：浏览器与服务器之间连接的类型\nCookie：当前页面设置的任何Cookie\n146Host：发出请求的页面所在的域\nReferer：发出请求的页面的URL\nUser-Agent：浏览器的用户代理字符串\nHTTPResponsesHeader常见的响应头：\nDate：表示消息发送的时间，时间的描述格式由rfc822定义\nserver:服务器名称\nConnection：浏览器与服务器之间连接的类型\nCache-Control：控制HTTP缓存\ncontent-type:表示后面的文档属于什么MIME类型\n常见的Content-Type属性值有以下四种：\n（1）application/x-www-form-urlencoded：浏览器的原生form表\n单，如果不设置enctype属性，那么最终就会以\napplication/x-www-form-urlencoded方式提交数据。该种方式提交\n的数据放在body里面，数据按照key1=val1&key2=val2的方式进\n行编码，key和val都进行了URL转码。\n（2）multipart/form-data：该种方式也是一个常见的POST提交方\n式，通常表单上传文件时使用该种方式。\n（3）application/json：服务器消息主体是序列化后的JSON字符\n串。\n（4）text/xml：该种方式主要用来提交XML格式的数据。\n4.常见的HTTP请求方法\nGET:向服务器获取数据；\n147POST：将实体提交到指定的资源，通常会造成服务器资源的修改；\nPUT：上传文件，更新数据；\nDELETE：删除服务器上的对象；\nHEAD：获取报文首部，与GET相比，不返回报文主体部分；\nOPTIONS：询问支持的请求方法，用来跨域请求；\nCONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP\n通信；\nTRACE:回显服务器收到的请求，主要⽤于测试或诊断。\n5.HTTP1.1和HTTP2.0的区别\n二进制协议：HTTP/2是一个二进制协议。在HTTP/1.1版中，报文\n的头信息必须是文本（ASCII编码），数据体可以是文本，也可以是\n二进制。HTTP/2则是一个彻底的二进制协议，头信息和数据体都是\n二进制，并且统称为\"帧\"，可以分为头信息帧和数据帧。帧的概念\n是它实现多路复用的基础。\n多路复用：HTTP/2实现了多路复用，HTTP/2仍然复用TCP连接，\n但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，\n而且不用按照顺序一一发送，这样就避免了\"队头堵塞\"的问题。\n数据流：HTTP/2使用了数据流的概念，因为HTTP/2的数据包是不\n按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。\n因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2将每\n个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个\n独一无二的编号。数据包发送时，都必须标记数据流ID，用来区分\n它属于哪个数据流。\n148头信息压缩：HTTP/2实现了头信息压缩，由于HTTP1.1协议不带\n状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重\n复的，比如Cookie和UserAgent，一模一样的内容，每次请求都\n必须附带，这会浪费很多带宽，也影响速度。HTTP/2对这一点做了\n优化，引入了头信息压缩机制。一方面，头信息使用gzip或\ncompress压缩后再发送；另一方面，客户端和服务器同时维护一张\n头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发\n送同样字段了，只发送索引号，这样就能提高速度了。\n服务器推送：HTTP/2允许服务器未经请求，主动向客户端发送资源，\n这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，\n这样就可以相对减少一些延迟时间。这里需要注意的是http2下服\n务器主动推送的是静态资源，和WebSocket以及使用SSE等方式向\n客户端发送即时数据的推送是不同的。\n6.HTTP和HTTPS协议的区别\nHTTP和HTTPS协议的主要区别如下：\nHTTPS协议需要CA证书，费用较高；而HTTP协议不需要；\nHTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安\n全性的SSL加密传输协议；\n使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协\n议端口是443；\nHTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协\n议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。\n7.HTTP2的头部压缩算法是怎样的？\n149HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，\n用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，\n可以达到50%~90%的高压缩率。\n具体来说:\n在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，\n对于相同的数据，不再通过每次请求和响应发送；\n首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同\n渐进地更新；\n每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前\n的值。\n例如下图中的两个请求，请求一发送了所有的头部字段，第二个请\n求则只需要发送差异数据，这样可以减少冗余数据，降低开销。\n1508.说一下HTTP3.0\nHTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可\n靠性等功能，这套功能被称为QUIC协议。\n1.流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来\n保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一\n些TCP中的特性。\n2.集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的\nRTT数。\n3.多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了\n数据流的单独传输，解决了TCP的队头阻塞问题。\n1514.快速握手：由于基于UDP，可以实现使用0~1个RTT来建立连接。\n9.什么是HTTPS协议？\n超文本传输安全协议（HypertextTransferProtocolSecure，简称：\nHTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经\n由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的\n是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\nHTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持\n的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功\n能，可以避免此类问题发生。\n安全层的主要职责就是对发起的HTTP请求的数据进行加密操作和\n对接收到的HTTP的内容进行解密操作。\n10.HTTPS通信（握手）过程\nHTTPS的通信过程如下：\n1.客户端向服务器发起请求，请求中包含使用的协议版本号、生成的\n一个随机数、以及客户端支持的加密方法。\n1522.服务器端接收到请求后，确认双方使用的加密方法、并给出服务器\n的证书、以及一个服务器生成的随机数。\n3.客户端确认服务器证书有效后，生成一个新的随机数，并使用数字\n证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供\n一个前面所有内容的hash的值，用来供服务器检验。\n4.服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供\n前面所有内容的hash值来供客户端检验。\n5.客户端和服务器端根据约定的加密方法使用前面的三个随机数，生\n成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。\n11.DNS完整的查询过程\nDNS服务器解析域名的过程：\n首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，\n若找不到继续下一步\n将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果\n查找到，就直接将查找结果返回，若找不到继续下一步\n本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个\n所查询域的顶级域名服务器地址\n本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询\n自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的\n下一级的权威域名服务器的地址\n本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的\n结果\n本地DNS服务器将返回结果保存在缓存中，便于下次使用\n153本地DNS服务器将返回结果返回给浏览器\n比如要查询www.baidu.com的IP地址，首先会在浏览器的缓存中\n查找是否有该域名的缓存，如果不存在就将请求发送到本地的DNS\n服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存\n在，则向根域名服务器发送一个请求，根域名服务器返回负责.com\n的顶级域名服务器的IP地址的列表。然后本地DNS服务器再向其\n中一个负责.com的顶级域名服务器发送一个请求，负责.com的顶\n级域名服务器返回负责.baidu的权威域名服务器的IP地址列表。\n然后本地DNS服务器再向其中一个权威域名服务器发送一个请求，\n最后权威域名服务器返回一个对应的主机名的IP地址列表。\n12.OSI七层模型\nISO为了更好的使网络应用更为普及，推出了OSI参考模型。\n（1）应用层\n154OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，\n也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：\nHTTP，HTTPS，FTP，POP3、SMTP等。\n在客户端与服务器中经常会有数据的请求，这个时候就是会用到\nhttp(hypertexttransferprotocol)(超文本传输协议)或者https.\n在后端设计数据接口时，我们常常使用到这个协议。\nFTP是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，\n在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。\nSMTP是simplemailtransferprotocol（简单邮件传输协议）。在\n一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。\n（2）表示层\n表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的\n应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可\n提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通\n信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换\n功能之一。\n在项目开发中，为了方便数据传输，可以使用base64对数据进行编\n解码。如果按功能来划分，base64应该是工作在表示层。\n（3）会话层\n会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层\n的通信由不同设备中的应用程序之间的服务请求和响应组成。\n（4）传输层\n155传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端\n到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等\n问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只\n是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、\n可靠的数据通路。我们通常说的，TCPUDP就是在这一层。端口号既\n是这里的“端”。\n（5）网络层\n本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来\n的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目\n的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协\n议层。IP协议是Internet的基础。我们可以这样理解，网络层规定\n了数据包的传输路线，而传输层则规定了数据包的传输方式。\n（6）数据链路层\n将比特组合成字节,再将字节组合成帧,使用链路层地址(以太网使\n用MAC地址)来访问介质,并进行差错检测。\n网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理\n解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。\n不过，在数据链路层上还增加了差错控制的功能。\n（7）物理层\n实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。\n规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、\n中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的\n传输介质。\nOSI七层模型通信特点：对等通信\n156对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一\n层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。\n在每一层通信过程中，使用本层自己协议进行通信。\n13.TCP的三次握手和四次挥手\n（1）三次握手\n三次握手（Three-wayHandshake）其实就是指建立一个TCP连接时，\n需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是\n为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序\n列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端\n口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗\n口大小信息。\n刚开始客户端处于Closed的状态，服务端处于Listen状态。\n157第一次握手：客户端给服务端发一个SYN报文，并指明客户端的初\n始化序列号ISN，此时客户端处于SYN_SEND状态。\n首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数\n据，但要消耗掉一个序号。\n第二次握手：服务器收到客户端的SYN报文之后，会以自己的SYN\n报文作为应答，并且也是指定了自己的初始化序列号ISN。同时会把\n客户端的ISN+1作为ACK的值，表示自己已经收到了客户端的SYN，\n此时服务器处于SYN_REVD的状态。\n在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y\n第三次握手：客户端收到SYN报文之后，会发送一个ACK报文，当\n然，也是一样把服务器的ISN+1作为ACK的值，表示已经收到了\n服务端的SYN报文，此时客户端处于ESTABLISHED状态。服务器收\n到ACK报文之后，也处于ESTABLISHED状态，此时，双方已建立起\n了连接。\n确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，\n第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则\n不消耗序号。\n那为什么要三次握手呢？两次不行吗？\n为了确认双方的接收能力和发送能力都正常\n如果是用两次握手，则会出现下面这种情况：\n如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是\n客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传\n输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其\n158中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是\n在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到\n达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是\n就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要\n服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的\n确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\n简单来说就是以下三步：\n第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含\n自身的数据通讯初始序号。请求发送后，客户端便进入SYN-SENT状\n态。\n第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发\n送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成\n后便进入SYN-RECEIVED状态。\n第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一\n个确认报文。客户端发完这个报文段后便进入ESTABLISHED状态，\n服务端收到这个应答后也进入ESTABLISHED状态，此时连接建立成\n功。\nTCP三次握手的建立连接的过程就是相互确认初始序号的过程，告诉\n对方，什么样序号的报文段能够被正确接收。第三次握手的作用是\n客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服\n务器就没有办法知道自己的序号是否已被确认。同时这样也是为了\n防止失效的请求报文段被服务器接收，而出现错误的情况。\n（2）四次挥手\n159\n刚开始双方都处于ESTABLISHED状态，假如是客户端先发起关闭请\n求。四次挥手的过程如下：\n第一次挥手：客户端会发送一个FIN报文，报文中会指定一个序列\n号。此时客户端处于FIN_WAIT1状态。\n即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，\n主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务\n端的确认。\n第二次挥手：服务端收到FIN之后，会发送ACK报文，且把客户端\n的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的\n报文了，此时服务端处于CLOSE_WAIT状态。\n即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号\nack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，\n此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收\n160到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务\n端发出的连接释放报文段。\n第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一\n样，发给FIN报文，且指定一个序列号。此时服务端处于LAST_ACK\n的状态。\n即服务端没有要向客户端发出的数据，服务端发出连接释放报文段\n（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK\n（最后确认）状态，等待客户端的确认。\n第四次挥手：客户端收到FIN之后，一样发送一个ACK报文作为应\n答，且把服务端的序列号值+1作为自己ACK报文的序列号值，此\n时客户端处于TIME_WAIT状态。需要过一阵子以确保服务端收到自\n己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之\n后，就处于关闭连接了，处于CLOSED状态。\n即客户端收到服务端的连接释放报文段后，对此发出确认报文段\n（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）\n状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL\n后，客户端才进入CLOSED状态。\n那为什么需要四次挥手呢？\n因为当服务端收到客户端的SYN连接请求报文后，可以直接发送\nSYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。\n但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭\nSOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN\n报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能\n发送FIN报文，因此不能一起发送，故需要四次挥手。\n161简单来说就是以下四步：\n第一次挥手：若客户端认为数据发送完成，则它需要向服务端发送连\n接释放请求。\n第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放TCP\n链接。然后会发送ACK包，并进入CLOSE_WAIT状态，此时表明客\n户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因\n为TCP连接是双向的，所以服务端仍旧可以发送数据给客户端。\n第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后\n会向客户端发送连接释放请求，然后服务端便进入LAST-ACK状态。\n第四次挥手：客户端收到释放请求后，向服务端发送确认应答，此时\n客户端进入TIME-WAIT状态。该状态会持续2MSL（最大段生存期，\n指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段\n内没有服务端的重发请求的话，就进入CLOSED状态。当服务端收到\n确认应答后，也便进入CLOSED状态。\nTCP使用四次挥手的原因是因为TCP的连接是全双工的，所以需要\n双方分别释放到对方的连接，单独一方的连接释放，只代表不能再\n向对方发送数据，连接处于的是半释放的状态。\n最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止\n发送给服务器的确认报文段丢失或者出错，从而导致服务器端不能\n正常关闭。\nHTML部分\n1.对HTML语义化的理解\n162语义化是指根据内容的结构化（内容语义化），选择合适的标签（代\n码语义化）。通俗来讲就是用正确的标签做正确的事情。\n语义化的优点如下：\n对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬\n取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据\n文章可以自动生成目录；\n对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发\n者能清晰的看出网页的结构，便于团队的开发与维护。\n常见的语义化标签：\n2.DOCTYPE(⽂档类型)的作⽤\nDOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目\n的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类\n型定义来解析文档，不同的渲染模式会影响浏览器对CSS代码甚⾄\nJavaScript脚本的解析。它必须声明在HTML⽂档的第⼀⾏。\n浏览器渲染页面的两种模式（可通过document.compatMode获取，比\n如，语雀官网的文档类型是CSS1Compat）：\n163CSS1Compat：标准模式（Strickmode），默认模式，浏览器使用W3C\n的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈\n现页面。\nBackCompat：怪异模式(混杂模式)(Quickmode)，浏览器使用自己的\n怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后\n兼容的方式显示。\n3.script标签中defer和async的区别\n如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。\n它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样\n就阻塞了后续文档的加载。\n下图可以直观的看出三者之间的区别:\n其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿\n色代表html解析。\ndefer和async属性都是去异步加载外部的JS脚本文件，它们都不\n会阻塞页面的解析，其区别如下：\n执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带\ndefer属性的标签，按照加载顺序执行；\n脚本是否并行执行：async属性，表示后续文档的加载和执行与js\n脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后\n续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的\n164(异步)，js脚本需要等到文档所有元素解析完成之后才执行，\nDOMContentLoaded事件触发执行之前。\n4.行内元素有哪些？块级元素有哪些？空(void)元素有那\n些？\n行内元素有：abspanimginputselectstrong；\n块级元素有：divulollidldtddh1h2h3h4h5h6p；\n空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，\n也就是空元素没有闭合标签：\n常见的有：<br>、<hr>、<img>、<input>、<link>、<meta>；\n鲜见的有：<area>、<base>、<col>、<colgroup>、<command>、<embed>、\n<keygen>、<param>、<source>、<track>、<wbr>。\n5.浏览器是如何对HTML5的离线储存资源进行管理和加载？\n在线的情况下，浏览器发现html头部有manifest属性，它会请求\nmanifest文件，如果是第一次访问页面，那么浏览器就会根据\nmanifest文件的内容下载相应的资源并且进行离线存储。如果已经\n访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线\n的资源加载页面，然后浏览器会对比新的manifest文件与旧的\nmanifest文件，如果文件没有发生改变，就不做任何操作，如果文\n件改变了，就会重新下载文件中的资源并进行离线存储。\n离线的情况下，浏览器会直接使用离线存储的资源。\n6.Canvas和SVG的区别\n（1）SVG：\n165SVG可缩放矢量图形（ScalableVectorGraphics）是基于可扩展标\n记语言XML描述的2D图形的语言，SVG基于XML就意味着SVGDOM\n中的每个元素都是可用的，可以为某个元素附加Javascript事件处\n理器。在SVG中，每个被绘制的图形均被视为对象。如果SVG对象\n的属性发生变化，那么浏览器能够自动重现图形。\n其特点如下：\n不依赖分辨率\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）\n不适合游戏应用\n（2）Canvas：\nCanvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲\n染的。其位置发生改变，就会重新进行绘制。\n其特点如下：\n依赖分辨率\n不支持事件处理器\n弱的文本渲染能力\n能够以.png或.jpg格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一\n系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是\n166一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等\n属性。\n7.说一下HTML5dragAPI\ndragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。\ndarg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。\ndragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。\ndragover：事件主体是目标元素，在被拖放在某元素内移动时触发。\ndragleave：事件主体是目标元素，在被拖放元素移出目标元素是触\n发。\ndrop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。\ndragend：事件主体是被拖放元素，在整个拖放操作结束时触发。\nCSS部分\n1.display的block、inline和inline-block的区别\n（1）block：会独占一行，多个元素会另起一行，可以设置width、\nheight、margin和padding属性；\n（2）inline：元素不会独占一行，设置width、height属性无效。\n但可以设置水平方向的margin和padding属性，不能设置垂直方向\n的padding和margin；\n（3）inline-block：将对象设置为inline对象，但对象的内容作为\nblock对象呈现，之后的内联对象会被排列在同一行内。\n对于行内元素和块级元素，其特点如下：\n（1）行内元素\n167设置宽高无效；\n可以设置水平方向的margin和padding属性，不能设置垂直方向的\npadding和margin；\n不会自动换行；\n（2）块级元素\n可以设置宽高；\n设置margin和padding都有效；\n可以自动换行；\n多个块状，默认排列从上到下。\n2.link和@import的区别\n两者都是外部引用CSS的方式，它们的区别如下：\nlink是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；\n@import属于CSS范畴，只能加载CSS。\nlink引用CSS时，在页面载入时同时加载；@import需要页面网页完\n全载入以后加载。\nlink是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低\n版本的浏览器不支持。\nlink支持使用Javascript控制DOM去改变样式；而@import不支持。\n3.CSS3中有哪些新特性\n新增各种CSS选择器（:not(.input)：所有class不是“input”\n的节点）\n圆角（border-radius:8px）\n168多列布局（multi-columnlayout）\n阴影和反射（Shadoweflect）\n文字特效（text-shadow）\n文字渲染（Text-decoration）\n线性渐变（gradient）\n旋转（transform）\n增加了旋转,缩放,定位,倾斜,动画,多背景\n4.对CSSSprites的理解\nCSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张\n大图中去，然后利用CSS的background-image，background-repeat，\nbackground-position属性的组合进行背景定位。\n优点：\n利用CSSSprites能很好地减少网页的http请求，从而大大提高了\n页面的性能，这是CSSSprites最大的优点；\nCSSSprites能减少图片的字节，把3张图片合并成1张图片的字节\n总是小于这3张图片的字节总和。\n缺点：\n在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要\n留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率\n下的自适应页面，如果背景不够宽，很容易出现背景断裂；\nCSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop\n或其他工具来对每个背景单元测量其准确的位置。\n169维护方面：CSSSprites在维护的时候比较麻烦，页面背景有少许改\n动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免\n改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加\n图片，这样图片的字节就增加了，还要改动CSS。\n5.CSS优化和提高性能的方法有哪些？\n加载性能：\n（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。\n（2）css单一样式：当需要下边距和左边距的时候，很多时候会选\n择使用 margin:top0bottom0；但\nmargin-bottom:bottom;margin-left:left;执行效率会更高。\n（3）减少使用@import，建议使用link，因为后者在页面加载时一\n起加载，前者是等待页面加载完成之后再进行加载。\n选择器性能：\n（1）关键选择器（keyselector）。选择器的最后面的部分为关键\n选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行\n匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定\n是否是指定的元素等等；\n（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加\n标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们\n了）。\n（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素\n进行选择。\n（4）尽量少的去对标签进行选择，而是用class。\n170（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择\n器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三\n层，更多的使用类来关联每一个标签元素。\n（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重\n复指定规则。\n渲染性能：\n（1）慎重使用高性能属性：浮动、定位。\n（2）尽量减少页面重排、重绘。\n（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样\n式。去除这些空规则无疑能减少css文档体积。\n（4）属性值为0时，不加单位。\n（5）属性值为浮动小数0.**，可以省略小数点之前的0。\n（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。\n（7）不使用@import前缀，它会影响css的加载速度。\n（8）选择器优化嵌套，尽量避免层级过深。\n（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页\n面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，\n再使用。\n（10）正确使用display的属性，由于display的作用，某些样式组\n合会无效，徒增样式体积的同时也影响解析性能。\n171（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，\n国外却很流行。webfonts通常体积庞大，而且一些浏览器在下载web\nfonts时会阻塞页面渲染损伤性能。\n可维护性、健壮性：\n（1）将具有相同属性的样式抽离出来，整合并通过class在页面中\n进行使用，提高css的可维护性。\n（2）样式与内容分离：将css代码定义到外部css中。\n6.对CSS工程化的理解\nCSS工程化是为了解决以下问题：\n1.宏观设计：CSS代码如何组织、如何拆分、模块结构怎样设计？\n2.编码优化：怎样写出更好的CSS？\n3.构建：如何处理我的CSS，才能让它的打包结果最优？\n4.可维护性：代码写完了，如何最小化它后续的变更成本？如何确保\n任何一个同事都能轻松接手？\n以下三个方向都是时下比较流行的、普适性非常好的CSS工程化实\n践：\n预处理器：Less、Sass等；\n重要的工程化插件：PostCss；\nWebpackloader等。\n基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们\n逐个来看：\n172（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问\n题？\n预处理器，其实就是CSS世界的“轮子”。预处理器支持我们写一\n种类似CSS、但实际并不是CSS的语言，然后把它编译成CSS代码：\n那为什么写CSS代码写得好好的，偏偏要转去写“类CSS”呢？这\n就和本来用JS也可以实现所有功能，但最后却写React的jsx或\n者Vue的模板语法一样——为了爽！要想知道有了预处理器有多爽，\n首先要知道的是传统CSS有多不爽。随着前端业务复杂度的提高，\n前端工程中对CSS提出了以下的诉求：\n1.宏观设计上：我们希望能优化CSS文件的目录结构，对现有的CSS\n文件实现复用；\n2.编码优化上：我们希望能写出结构清晰、简明易懂的CSS，需要它\n具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们\n希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这\n样我们可以少写一些无用的代码；\n3.可维护性上：更强的可编程性意味着更优质的代码结构，实现复用\n意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自\n然会带来更强的可维护性。\n这三点是传统CSS所做不到的，也正是预处理器所解决掉的问题。\n预处理器普遍会具备这样的特性：\n173嵌套代码的能力，通过嵌套来反映不同css属性之间的层级关系；\n支持定义css变量；\n提供计算函数；\n允许对代码片段进行extend和mixin；\n支持循环语句的使用；\n支持将CSS文件模块化，实现复用。\n（2）PostCss：PostCss是如何工作的？我们在什么场景下会使用\nPostCss？\nPostCss仍然是一个对CSS进行解析和处理的工具，它会对CSS做\n这样的事情：\n它和预处理器的不同就在于，预处理器处理的是类CSS，而PostCss\n处理的就是CSS本身。Babel可以将高版本的JS代码转换为低版\n本的JS代码。PostCss做的是类似的事情：它可以编译尚未被浏览\n器广泛支持的先进的CSS语法，还可以自动为一些需要额外兼容的\n语法增加前缀。更强的是，由于PostCss有着强大的插件机制，支\n持各种各样的扩展，极大地强化了CSS的能力。\nPostCss在业务中的使用场景非常多：\n提高CSS代码的可读性：PostCss其实可以做类似预处理器能做的\n工作；\n174当我们的CSS代码需要适配低版本浏览器时，PostCss的\nAutoprefixer插件可以帮助我们自动增加浏览器前缀；\n允许我们编写面向未来的CSS：PostCss能够帮助我们编译CSS\nnext代码；\n（3）Webpack能处理CSS吗？如何实现？\nWebpack能处理CSS吗：\nWebpack在裸奔的状态下，是不能处理CSS的，Webpack本身是一\n个面向JavaScript且只能处理JavaScript代码的模块化打包工\n具；\nWebpack在loader的辅助下，是可以处理CSS的。\n如何用Webpack实现对CSS的处理：\nWebpack中操作CSS需要使用的两个关键的loader：css-loader\n和style-loader\n注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在\n背答案，所以你还需要了解每个loader都做了什么事情：\ncss-loader：导入CSS模块，对CSS代码进行编译处理；\nstyle-loader：创建style标签，把CSS内容写入标签。\n在实际使用中，css-loader的执行顺序一定要安排在style-loader\n的前面。因为只有完成了编译过程，才可以对css代码进行插入；\n若提前插入了未编译的代码，那么webpack是无法理解这坨东西的，\n它会无情报错。\n7.常见的CSS布局单位\n常用的布局单位包括像素（px），百分比（%），em，rem，vw/vh。\n175（1）像素（px）是页面布局的基础，一个像素表示终端（电脑、手\n机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS\n像素和物理像素：\nCSS像素：为web开发者提供，在CSS中使用的一个抽象单位；\n物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定\n的。\n（2）百分比（%），当浏览器的宽度或者高度发生变化时，通过百分\n比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，\n从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。\n（3）em和rem相对于px更具灵活性，它们都是相对长度单位，它\n们之间的区别：em相对于父元素，rem相对于根元素。\nem：文本相对长度单位。相对于当前对象内文本的字体尺寸。如果\n当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体\n尺寸(默认16px)。(相对父元素的字体大小倍数)。\nrem：rem是CSS3新增的一个相对单位，相对于根元素（html元素）\n的font-size的倍数。作用：利用rem可以实现简单的响应式布局，\n可以利用html元素中字体的大小与屏幕间的比值来设置font-size\n的值，以此实现当屏幕分辨率变化时让元素也随之变化。\n（4）vw/vh是与视图窗口有关的单位，vw表示相对于视图窗口的宽\n度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax\n两个相关的单位。\nvw：相对于视窗的宽度，视窗宽度是100vw；\n176vh：相对于视窗的高度，视窗高度是100vh；\nvmin：vw和vh中的较小值；\nvmax：vw和vh中的较大值；\nvw/vh和百分比很类似，两者的区别：\n百分比（%）：大部分相对于祖先元素，也有相对于自身的情况比如\n（border-radius、translate等)\nvw/vm：相对于视窗的尺寸\n8.水平垂直居中的实现\n利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页\n面的中心，然后再通过translate来调整元素的中心点到页面的中心。\n该方法需要考虑浏览器兼容问题。\n利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，\n由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上\n的居中。该方法适用于盒子有宽高的情况：\n177利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页\n面的中心，然后再通过margin负值来调整元素的中心点到页面的中\n心。该方法适用于盒子宽高已知的情况\n使用flex布局，通过align-items:center和\njustify-content:center设置容器的垂直和水平方向上为居中对齐，\n然后它的子元素也可以实现垂直和水平的居中。该方法要考虑兼容的\n问题，该方法在移动端用的较多：\n9.对BFC的理解，如何创建BFC\n先来看两个相关的概念：\nBox:Box是CSS布局的对象和基本单位，⼀个⻚⾯是由很多个Box\n组成的，这个Box就是我们所说的盒模型。\nFormattingcontext：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区\n域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其\n他元素的关系和相互作⽤。178块格式化上下文（BlockFormattingContext，BFC）是Web页面的\n可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是\n浮动元素与其他元素的交互限定区域。\n通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这\n个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物\n品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外\n部影响。\n创建BFC的条件：\n根元素：body；\n元素设置浮动：float除none以外的值；\n元素设置绝对定位：position(absolute、fixed)；\ndisplay值为：inline-block、table-cell、table-caption、flex\n等；\noverflow值为：hidden、auto、scroll；\nBFC的特点：\n垂直方向上，自上而下排列，和文档流的排列方式一致。\n在BFC中上下相邻的两个容器的margin会重叠\n计算BFC的高度时，需要计算浮动元素的高度\nBFC区域不会与浮动的容器发生重叠\nBFC是独立的容器，容器内部元素不会影响外部元素\n每个元素的左margin值和容器的左border相接触\nBFC的作用：\n179解决margin的重叠问题：由于BFC是一个独立的区域，内部的元素\n和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin\n重叠的问题。\n解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌\n陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变\n成一个BFC。常用的办法是给父元素设置overflow:hidden。\n创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固\n定，右边的宽度自适应。\n左侧设置float:left，右侧设置overflow:hidden。这样右边就触\n发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发\n生重叠，实现了自适应两栏布局。\n10.元素的层叠顺序\n层叠顺序，英文称作stackingorder，表示元素发生层叠时有着特\n定的垂直显示顺序。下面是盒模型的层叠规则：\n180\n对于上图，由上到下分别是：\n（1）背景和边框：建立当前层叠上下文元素的背景和边框。\n（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。\n（3）块级盒：文档流内非行内级非定位后代元素。\n（4）浮动盒：非定位浮动元素。\n（5）行内盒：文档流内行内级非定位后代元素。\n（6）z-index:0：层叠级数为0的定位元素。\n（7）正z-index：z-index属性值为正的定位元素。\n注意:当定位元素z-index:auto，生成盒在当前层叠上下文中的层\n级为0，不会建立新的层叠上下文，除非是根元素。\n11.如何解决1px问题？\n1px问题指的是：在一些Retina屏幕的机型上，移动端页面的1px\n会变得很粗，呈现出不止1px的效果。原因很简单——CSS中的1px\n181并不能和移动设备上的1px划等号。它们之间的比例关系有一个专\n门的属性来描述：\n打开Chrome浏览器，启动移动端调试模式，在控制台去输出这个\ndevicePixelRatio的值。这里选中iPhone6/7/8这系列的机型，输\n出的结果就是2：\n这就意味着设置的1pxCSS像素，在这个设备上实际会用2个物理\n像素单元来进行渲染，所以实际看到的一定会比1px粗一些。\n解决1px问题的三种思路：\n思路一：直接写0.5px\n如果之前1px的样式这样写：\n可以先在JS中拿到window.devicePixelRatio的值，然后把这个\n值通过JSX或者模板语法给到CSS的data里，达到这样的效果\n（这里用JSX语法做示范）：\n然后就可以在CSS中用属性选择器来命中devicePixelRatio为某\n一值的情况，比如说这里尝试命中devicePixelRatio为2的情况：\n182\n直接把1px改成1/devicePixelRatio后的值，这是目前为止最简\n单的一种方法。这种方法的缺陷在于兼容性不行，IOS系统需要8及\n以上的版本，安卓系统则直接不兼容。\n思路二：伪元素先放大后缩小\n这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。\n思路是先放大、后缩小：在目标元素的后面追加一个::after伪元\n素，让这个元素布局为absolute之后、整个伸展开铺在目标元素上，\n然后把它的宽和高都设置为目标元素的两倍，border值设为1px。\n接着借助CSS动画特效中的放缩能力，把整个伪元素缩小为原来的\n50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而border\n也缩小为了1px的二分之一，间接地实现了0.5px的效果。\n代码如下：\n本文收集整理于语雀博主[CUGGZ]的原创文章\n原文链接：\nhttps://www.yuque.com/cuggz/interview"
}