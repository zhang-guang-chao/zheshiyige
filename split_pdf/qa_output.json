{
  "total_qa_pairs": 167,
  "qa_pairs": [
    {
      "question": "JavaScript有哪些数据类型？",
      "answer": "JavaScript共有八种数据类型，分别是Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。"
    },
    {
      "question": "什么是Symbol数据类型？",
      "answer": "Symbol代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。"
    },
    {
      "question": "如何获取安全的undefined值？",
      "answer": "因为undefined是一个标识符，可被当作变量使用和赋值，会影响其正常判断。表达式void___没有返回值，返回结果是undefined，void并不改变表达式的结果，只是让表达式不返回值，因此可以用void0来获得undefined。"
    },
    {
      "question": "使用双等号（==）、三等号（===）和Object.is()进行相等判断时有什么区别？",
      "answer": "使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较；使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回false；使用Object.is来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0和+0不再相等，两个NaN是相等的。"
    },
    {
      "question": "如何判断一个对象是空对象？",
      "answer": "使用JSON自带的.stringify方法来判断；使用ES6新增的方法Object.keys()来判断。"
    },
    {
      "question": "const对象的属性可以修改吗？为什么？",
      "answer": "const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。"
    },
    {
      "question": "new操作符的实现步骤是什么？",
      "answer": "1.创建一个对象；2.将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）；3.指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）；4.返回新的对象。"
    },
    {
      "question": "什么是对象扩展运算符？",
      "answer": "对象的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。"
    },
    {
      "question": "JSON.stringify函数和JSON.parse函数的作用分别是什么？",
      "answer": "JSON.stringify函数，通过传入一个符合JSON格式的数据结构，将其转换为一个JSON字符串。如果传入的数据结构不符合JSON格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。JSON.parse()函数，用来将JSON格式的字符串转换为一个js数据结构，如果传入的字符串不是标准的JSON格式的字符串的话，将会抛出错误。"
    },
    {
      "question": "给js脚本添加defer属性有什么作用？",
      "answer": "这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文 件，这样的话就能使页面的渲染不被阻塞。多个设置了defer属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。"
    },
    {
      "question": "什么是DOM和BOM？",
      "answer": "DOM指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。BOM指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。"
    },
    {
      "question": "创建AJAX请求的步骤是什么？",
      "answer": "1. 创建一个XMLHttpRequest对象。2. 在这个对象上使用open方法创建一个HTTP请求，open方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。3. 在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过setRequestHeader方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个XMLHttpRequest对象一共有5个状态，当它的状态变化时会触发onreadystatechange事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的readyState变为4的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是2xx或者304的话则代表返回正常。这个时候就可以通过response中的数据来对页面进行更新了。4. 当对象的属性和监听函数设置完成后，最后调用sent方法来向服务器发起请求，可以传入参数作为发送的数据体。"
    },
    {
      "question": "ES6Module和CommonJS模块的区别是什么？",
      "answer": "CommonJS是对模块的浅拷⻉，ES6Module是对模块的引⽤，即ES6Module只存只读，不能改变其值，也就是指针指向不能变，类似const；import的接⼝是read-only（只读状态），不能修改其变量值。即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6Module赋值会编译报错。"
    },
    {
      "question": "for...in和for...of的区别是什么？",
      "answer": "1. for…of遍历获取的是对象的键值，for…in获取的是对象的键名；2. for…in会遍历对象的整个原型链，性能非常差不推荐使用，而for…of只遍历当前对象不会遍历原型链；3. 对于数组的遍历，for…in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of只返回数组的下标对应的属性值；4. for...in循环主要是为了遍历对象而生，不适用于遍历数组；for...of循环可以用来遍历数组、类数组对象，字符串、Set、Map以及Generator对象。"
    },
    {
      "question": "fetch的优点有哪些？",
      "answer": "语法简洁，更加语义化；基于标准Promise实现，支持async/await；更加底层，提供的API丰富（request,response）；脱离了XHR，是ES规范里新的实现方式"
    },
    {
      "question": "什么是原型链？",
      "answer": "当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这就是原型链的概念。原型链的尽头一般来说都是Object.prototype。"
    },
    {
      "question": "如何在fetch中带上cookie？",
      "answer": "需要添加配置项：fetch(url, {credentials:'include'})"
    },
    {
      "question": "Axios的特点是什么？",
      "answer": "浏览器端发起XMLHttpRequests请求；node端发起http请求；支持PromiseAPI；监听请求和返回；对请求和返回进行转化；取消请求；自动转换json数据；客户端支持抵御XSRF攻击"
    },
    {
      "question": "this对象在函数调用模式下指向什么？",
      "answer": "当一个函数不是一个对象的属性时，直接作为函数来调用时，this指向全局对象。"
    },
    {
      "question": "call()和apply()的区别是什么？",
      "answer": "它们的作用一模一样，区别仅在于传入参数的形式的不同。apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数。"
    },
    {
      "question": "JavaScript中异步编程的实现方式有哪些？",
      "answer": "JavaScript中的异步机制可以分为以下几种：回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。Promise的方式，使用Promise的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个then的链式调用，可能会造成代码的语义不够明确。generator的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在generator内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行generator的机制，比如说co模块等方式来实现generator的自动执行。async函数的方式，async函数是generator和promise实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个await语句的时候，如果语句返回一个promise对象，那么函数将会等待promise对象的状态变为resolve后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。"
    },
    {
      "question": "什么是Promise？",
      "answer": "Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。"
    },
    {
      "question": "简述使用async/await的步骤",
      "answer": "async用于申明一个function是异步的，await用于等待一个异步方法执行完成。语法上强制规定await只能出现在asnyc函数中。async函数返回的是一个Promise对象，如果在函数中return一个直接量，async会把这个直接量通过Promise.resolve()封装成Promise对象。在最外层不能用await获取其返回值的情况下，用原来的方式：then()链"
    },
    {
      "question": "async函数没有返回值时会返回什么？",
      "answer": "它会返回Promise.resolve(undefined)。"
    },
    {
      "question": "什么是Promise.resolve(x)？",
      "answer": "Promise.resolve(x)可以看作是new Promise(resolve => resolve(x))的简写，可以用于快速封装字面量对象或其他对象，将其封装成Promise实例。"
    },
    {
      "question": "简述构造函数模式创建对象的执行过程",
      "answer": "执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的prototype属性，然后将执行上下文中的this指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。"
    },
    {
      "question": "async/await对比Promise有哪些优势？",
      "answer": "1. 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担；2. Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅；3. 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余；4. 调试友好，Promise的调试很差，由于没有代码块，不能在⼀个返回表达式的箭头函数中设置断点，在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。"
    },
    {
      "question": "组合继承的实现方式是什么？",
      "answer": "组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。"
    },
    {
      "question": "什么是原型式继承？",
      "answer": "原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5中定义的Object.create()方法就是原型式继承的实现。"
    },
    {
      "question": "Vue双向数据绑定主要分为哪几个步骤？",
      "answer": "1.需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化；2.compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图；3.Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:①在自身实例化时往属性订阅器(dep)里面添加自己②自身必须有一个update()方法③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退；4.MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。"
    },
    {
      "question": "MVC架构中各部分的职责是什么？",
      "answer": "MVC通过分离Model、View和Controller的方式来组织代码结构。其中View负责页面的显示逻辑，Model负责存储页面的业务数据，以及对相应数据的操作。并且View和Model应用了观察者模式，当Model层发生改变的时候它会通知有关View层更新页面。Controller层是View层和Model层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller中的事件触发器就开始工作了，通过调用Model层，来完成对Model的修改，然后Model层再去通知View层更新。"
    },
    {
      "question": "MVC模式存在什么问题？",
      "answer": "在MVC模式中使用观察者模式，来实现当Model层数据发生变化的时候，通知View层的更新。这样View层和Model层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。"
    },
    {
      "question": "什么是slot？",
      "answer": "slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。"
    },
    {
      "question": "简述$nextTick的实现原理",
      "answer": "Vue的nextTick其本质是对JavaScript执行原理EventLoop的一种应用。nextTick的核心是利用了如Promise、MutationObserver、setImmediate、setTimeout的原生JavaScript方法来模拟对应的微/宏任务的实现，本质是为了利用JavaScript的这些异步回调任务队列来实现Vue框架中自己的异步回调队列。"
    },
    {
      "question": "简述Vue实现数组方法实时更新的操作步骤",
      "answer": "首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__==arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。"
    },
    {
      "question": "Vue在更新DOM时是如何执行的？",
      "answer": "Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。然后，在下一个的事件循环tick中，Vue刷新队列并执行实际（已去重的）工作。"
    },
    {
      "question": "什么是高阶组件？",
      "answer": "高阶组件就是高阶函数。"
    },
    {
      "question": "简述mergeOptions的执行过程",
      "answer": "规范化选项（normalizeProps、normalizelnject、normalizeDirectives)，对未合并的选项，进行判断。"
    },
    {
      "question": "子组件如果想要改变父组件的数据应该怎么做？",
      "answer": "只能通过$emit派发一个自定义事件，父组件接收到后，由父组件修改。"
    },
    {
      "question": "assets和static存放静态资源文件时有什么不同点？",
      "answer": "assets中存放的静态资源文件在项目打包时（运行npmrunbuild）会进行打包上传（压缩体积，代码格式化），压缩后的文件最终会放置在static文件中跟着index.html一同上传至服务器。static中放置的静态资源文件不会走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。"
    },
    {
      "question": "static中的资源文件与assets中打包后的文件相比有什么特点？",
      "answer": "static中的资源文件由于没有进行压缩等操作，文件的体积相对于assets中打包后的文件较大，在服务器中会占据更大的空间。"
    },
    {
      "question": "什么是Vue模版编译？",
      "answer": "vue中的模板template无法被浏览器解析并渲染，需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，这个转化的过程就称为模板编译。"
    },
    {
      "question": "如何解决vue初始化页面闪动问题？",
      "answer": "首先在css里加上相关代码；如果没有彻底解决问题，则在根元素加上style=\"display: none;\":style=\"{display:'block'}\""
    },
    {
      "question": "MVVM的优点有哪些？",
      "answer": "分离视图（View）和模型（Model），降低代码耦合，提高视图或者逻辑的重用性；提高可测试性；自动更新dom。"
    },
    {
      "question": "v-if和v-for同时出现时应如何优化？",
      "answer": "在外层嵌套template，在这一层进行v-if判断，然后在内部进行v-for循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。"
    },
    {
      "question": "Vue高效性体现在哪些方面？",
      "answer": "超快的虚拟DOM和diﬀ算法使应用拥有最佳的性能表现。vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。"
    },
    {
      "question": "什么是Vue的生命周期？",
      "answer": "Vue实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom->渲染、更新->渲染、卸载等⼀系列过程，称这是Vue的⽣命周期。"
    },
    {
      "question": "Vue实例从加载渲染到销毁，父子组件的执行顺序分别是怎样的？",
      "answer": "加载渲染过程：1.父组件beforeCreate；2.父组件created；3.父组件beforeMount；4.子组件beforeCreate；5.子组件created；6.子组件beforeMount；7.子组件mounted；8.父组件mounted。更新过程：1.父组件beforeUpdate；2.子组件beforeUpdate；3.子组件updated；4.父组件updated。销毁过程：1.父组件beforeDestroy；2.子组件beforeDestroy；3.子组件destroyed；4.父组件destoryed。"
    },
    {
      "question": "created和mounted的区别是什么？",
      "answer": "created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。"
    },
    {
      "question": "Vue-Router的hash模式和history模式有什么区别？",
      "answer": "hash模式：是开发中默认的模式，URL带着一个#，hash值出现在URL里但不出现在HTTP请求中，不影响后端，改变hash值不重新加载页面，浏览器支持度好，主要原理是onhashchange()事件。history模式：URL中没有#，使用传统路由分发模式，需要后台配置支持，否则访问会返回404，historyapi可分为切换历史状态和修改历史状态，修改历史状态包括新增的pushState()和replaceState()方法。"
    },
    {
      "question": "历史记录栈提供了什么功能？",
      "answer": "历史记录栈提供了对历史记录进行修改的功能。"
    },
    {
      "question": "什么是Vuex？",
      "answer": "Vuex是一个专为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store（仓库），“store”基本上就是一个容器，它包含着应用中大部分的状态(state)。"
    },
    {
      "question": "如果想要切换到history模式，需要进行什么操作？",
      "answer": "如果想要切换到history模式，就要进行以下配置（后端也要进行配置）。"
    },
    {
      "question": "调用history.pushState()相比于直接修改hash，存在哪些优势？",
      "answer": "pushState()设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，因此只能设置与当前URL同文档的URL；pushState()设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发动 作将记录添加到栈中；pushState()通过stateObject参数可以添加任意类型的数据到记录中；而hash只可添加短字符串；pushState()可额外设置title属性供后续使用。"
    },
    {
      "question": "Vuex数据流的顺序是什么？",
      "answer": "View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）"
    },
    {
      "question": "Vuex有哪几种属性？",
      "answer": "有五种，分别是State、Getter、Mutation、Action、Module。state=>基本数据(数据源存放地)；getters=>从基本数据派生出来的数据；mutations=>提交更改数据的方法，同步；actions=>像一个装饰器，包裹mutations，使之可以异步；modules=>模块化Vuex"
    },
    {
      "question": "什么是Proxy？",
      "answer": "Proxy是ES6中提供的功能，用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）"
    },
    {
      "question": "Vue3.0在模板方面有哪些更新？",
      "answer": "作用域插槽，2.x的机制导致作用域插槽变了，父组件会重新渲染，而3.0把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于render函数的方面，vue3.0也会进行一系列更改来方便习惯直接使用api来生成vdom"
    },
    {
      "question": "虚拟DOM的解析过程是什么？",
      "answer": "首先对将要插入到文档中的DOM树结构进行分析，使用js对象将其表示出来，比如一个元素对象，包含TagName、props和Children这些属性。然后将这个js对象树给保存下来，最后再将DOM片段插入到文档中。当页面的状态发生改变，需要对页面的DOM的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的DOM树中去，这样视图就更新了。"
    },
    {
      "question": "什么是集合类型？",
      "answer": "对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。"
    },
    {
      "question": "DIFF算法在新老虚拟DOM对比时的操作步骤是什么？",
      "answer": "首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换；如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)；比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。匹配时，找到相同的子节点，递归比较子节点。在diff中，只对同层的子节点进行比较，放弃跨级的节点比较。"
    },
    {
      "question": "Vue中v-if使用key的作用是什么？",
      "answer": "Vue中v-if使用key时，由于Vue会尽可能高效地渲染元素，通常会复用已有元素。使用v-if实现元素切换时，若切换前后含有相同类型元素会被复用，相同input元素切换前后用户输入不会清除，不符合需求。通过使用key来唯一的标识一个元素，此时使用key的元素不会被复用，key的作用是用来标识一个独立的元素。"
    },
    {
      "question": "HOC的优点和缺点分别是什么？",
      "answer": "优点：逻辑服用、不影响被包裹组件的内部逻辑。缺点：hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖。"
    },
    {
      "question": "什么是Renderprops？",
      "answer": "“renderprop”是指一种在React组件之间使用一个值为函数的prop共享代码的简单技术。具有renderprop的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，“render”的命名可以是任何其他有效的标识符。"
    },
    {
      "question": "使用Hook有哪些注意事项？",
      "answer": "hook只能在组件顶层使用，不可在分支语句中使用。"
    },
    {
      "question": "React.createClass和extendsComponent在状态设置上有什么区别？",
      "answer": "React.createClass：通过getInitialState()方法返回一个包含初始值的对象；React.Component：通过constructor设置初始状态。"
    },
    {
      "question": "React中setState调用之后发生了什么？",
      "answer": "在代码中调用setState函数之后，React会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面。在React得到元素树之后，React会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。如果在短时间内频繁setState，React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。"
    },
    {
      "question": "在源码中，如何判断setState是先存进state队列还是直接更新？",
      "answer": "在源码中，通过isBatchingUpdates来判断setState是先存进state队列还是直接更新，如果值为true则执行异步操作，为false则直接更新。"
    },
    {
      "question": "什么是纯函数？",
      "answer": "纯函数有几个特点：给定相同的输入，总是返回相同的输出；过程没有副作用；不依赖外部状态。"
    },
    {
      "question": "在React中如何检验props？",
      "answer": "React为我们提供了PropTypes以供验证使用。当向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。如果项目中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。"
    },
    {
      "question": "React废弃了哪些生命周期函数？原因是什么？",
      "answer": "废弃的生命周期函数有componentWillMount、componentWillReceiveProps、componentWillUpdate。原因如下：componentWillMount功能可用componentDidMount和constructor代替，且在服务端使用会导致内存泄漏；componentWillReceiveProps会破坏state数据的单一数据源，增加组件重绘次数；componentWillUpdate中的回调函数可能在一次更新中被调用多次。另外，因fber的出现，这些在render之前的函数可能因高优先级任务打断现有任务而被执行多次，React想约束使用者写出易维护和扩展的代码。"
    },
    {
      "question": "React16.X中props改变后在哪个生命周期中处理？",
      "answer": "在getDerivedStateFromProps中进行处理。这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。"
    },
    {
      "question": "什么是Pre-commit阶段？",
      "answer": "所谓“commit”，这里指的是“更新真正的DOM节点”这个动作。所谓Pre-commit，就是说在这个阶段其实还并没有去更新真实的DOM，不过DOM信息已经是可以读取的了。"
    },
    {
      "question": "React16中新生命周期在更新过程包含哪些函数？",
      "answer": "更新过程：getDerivedStateFromProps、shouldComponentUpdate、render、getSnapshotBeforeUpdate、componentDidUpdate。"
    },
    {
      "question": "基于hash的路由如何实现？",
      "answer": "通过监听hashchange事件，感知hash的变化。改变hash可以直接通过location.hash=xxx。"
    },
    {
      "question": "Redux主要解决什么问题？",
      "answer": "随着JavaScript单页应用开发日趋复杂，管理不断变化的state非常困难。Redux提供了一个叫store的统一仓储库，组件通过dispatch将state直接传入store，不用通过其他的组件。并且组件通过subscribe从store获取到state的改变。使用了Redux，所有的组件都可以从store中获取到所需的state，他们也能从store获取到state的改变。单纯的Redux只是一个状态机，react-redux作用是将Redux的状态机和React的UI呈现绑定在一起，当dispatch action改变state的时候，会自动更新页面。"
    },
    {
      "question": "Redux和Vuex的区别是什么？",
      "answer": "Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可；Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可；Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变（vue检测到数据变化自动渲染）；通俗点理解就是，vuex弱化dispatch，通过commit进行store状态的一次更变；取消了action概念，不必传入特定的action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易。"
    },
    {
      "question": "什么是概念解释型问题中Redux和Vuex的共同思想？",
      "answer": "单一的数据源，变化可以预测，本质上∶redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。"
    },
    {
      "question": "Redux中间件是如何拿到store和action并处理的？",
      "answer": "redux中间件本质就是一个函数柯里化。reduxapplyMiddlewareApi源码中每个middleware接受2个参数，Store的getState函数和dispatch函数，分别获得store和action，最终返回一个函数。该函数会被传入next的下一个middleware的dispatch方法，并返回一个接收action的新函数，这个函数可以直接调用next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个middleware会接受真实的store的dispatch方法作为next参数，并借此结束调用链。所以，middleware的函数签名是（{getState，dispatch})=>next=>action。"
    },
    {
      "question": "ReactHooks解决了哪些问题？",
      "answer": "（1）在组件之间复用状态逻辑很难。可以使用Hook从组件中提取状态逻辑，在无需修改组件结构的情况下复用状态逻辑。（2）复杂组件变得难以理解。Hook将组件中相互关联的部分拆分成更小的函数，还可以使用reducer来管理组件的内部状态，使其更加可预测。（3）难以理解的class。Hook使你在非class的情况下可以使用更多的React特性。"
    },
    {
      "question": "ReactHooks的使用限制有哪些？",
      "answer": "不要在循环、条件或嵌套函数中调用Hook；在React的函数组件中调用Hook。"
    },
    {
      "question": "为什么不要在循环、条件或嵌套函数中调用Hook？",
      "answer": "因为Hooks的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的Hook。当然，实质上React的源码里不是数组，是链表。"
    },
    {
      "question": "什么是diff算法？",
      "answer": "diff算法探讨的就是虚拟DOM树发生变化后，生成DOM树更新补丁的方式。它通过对比新旧两株虚拟DOM树的变更差异，将更新补丁作用于真实DOM，以最小成本完成视图更新。"
    },
    {
      "question": "React diff算法的具体流程是什么？",
      "answer": "1. 真实的DOM首先会映射为虚拟DOM；2. 当虚拟DOM发生变化后，就会根据差距计算生成patch，这个patch是一个结构化的数据，内容包含了增加、更新、移除等；3. 根据patch去更新真实的DOM，反馈到用户的界面上。"
    },
    {
      "question": "React diff算法总结为哪三个策略？",
      "answer": "策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）策略二：如果组件的class一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）策略三：同一层级的子节点，可以通过标记key的方式进行列表对比。（基于节点进行对比）"
    },
    {
      "question": "Keys在React中有什么作用？",
      "answer": "Keys是React用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在ReactDiff算法中React会借助元素的Key值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React还需要借助Key值来判断元素与本地状态的关联关系。"
    },
    {
      "question": "React16.x有哪些新特性？",
      "answer": "React16.x的三大新特性TimeSlicing、Suspense、hooks。React16.8加入hooks；React16.9重命名Unsafe的生命周期方法、废弃javascript:形式的URL、废弃 \"Factory\" 组件、act（）支持异步函数、使用<React.ProfiLer>进行性能评估；React16.13.0支持在渲染期间调用setState、可检测冲突的样式规则并记录警告、废弃unstable_createPortal、将组件堆栈添加到其开发警告中。"
    },
    {
      "question": "什么是Redux中间件？",
      "answer": "Redux的中间件提供的是位于action被发起之后，到达reducer之前的扩展点，原本view->action->reducer->store的数据流加上中间件后变成了view->action->middleware->reducer->store，在这一环节可以做一些“副作用”的操作，如异步请求、打印日志等。"
    },
    {
      "question": "在React中，父组件向子组件如何通讯？",
      "answer": "父组件可以向子组件通过传props的方式，向子组件进行通讯。"
    },
    {
      "question": "React16.8加入的hooks解决了哪些问题？",
      "answer": "在组件间复用状态逻辑很难；复杂组件变得难以理解，高阶组件和函数组件的嵌套过深；class组件的this指向问题；难以记忆的生命周期。"
    },
    {
      "question": "在React中页面重新加载时保留数据的方式有哪些？",
      "answer": "Redux：将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；data.js：使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；sessionStorge：在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据；historyAPI：HistoryAPI的pushState函数可以给历史记录关联一个任意的可序列化state，所以可以在路由push的时候将当前页面的一些信息存到state中，下次返回到这个页面的时候就能从state里面取出离开前的数据重新渲染。react-router直接可以支持。这个方法适合一些需要临时存储的场景。"
    },
    {
      "question": "有哪些全局状态管理工具可用于通信，它们是如何工作的？",
      "answer": "借助Redux或者Mobx等全局状态管理工具进行通信，这种工具会维护一个全局状态中心Store，并根据不同的事件产生新的状态。"
    },
    {
      "question": "什么是懒加载？",
      "answer": "懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。"
    },
    {
      "question": "简述使用原生JavaScript实现懒加载的操作步骤。",
      "answer": "使用HTML5的data-xxx属性（这里使用data-src）来储存图片的路径，在需要加载图片的时候，将data-src中图片的路径赋值给src。实现重点在于确定用户需要加载哪张图片，当图片出现在可视区域时，获取图片的真实地址并赋值给图片。图片加载条件：img.offsetTop<window.innerHeight + document.body.scrollTop 。"
    },
    {
      "question": "什么是回流？哪些操作会导致回流？",
      "answer": "当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。导致回流的操作有：页面的首次渲染；浏览器的窗口大小发生变化；元素的内容发生变化；元素的尺寸或者位置发生变化；元素的字体大小发生变化；激活CSS伪类；查询某些属性或者调用某些方法；添加或者删除可见的DOM元素。"
    },
    {
      "question": "如何避免回流与重绘？",
      "answer": "减少回流与重绘的措施：操作DOM时，尽量在低层级的DOM节点进行操作；不要使用table布局；使用CSS的表达式；不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式；使用absolute或者fixed，使元素脱离文档流；避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中；将元素先设置display:none，操作结束后再把它显示出来；将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。"
    },
    {
      "question": "什么是函数防抖？",
      "answer": "函数防抖是指在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。"
    },
    {
      "question": "函数节流适用于哪些场景？",
      "answer": "拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动；缩放场景：监控浏览器resize；动画场景：避免短时间内多次触发动画引起性能问题。"
    },
    {
      "question": "如何对项目中的图片进行优化？",
      "answer": "1.不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用CSS去代替。2.对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。3.小图使用base64格式。4.将多个图标文件整合到一张图片中（雪碧图）。5.选择正确的图片格式：对于能够显示WebP格式的浏览器尽量使用WebP格式。小图使用PNG，其实对于大部分图标这类图片，完全可以使用SVG代替，照片使用JPEG。"
    },
    {
      "question": "WebP图片格式有什么特点？",
      "answer": "WebP是谷歌开发的一种新图片格式，是同时支持有损和无损压缩的、使用直接色的点阵图。相同质量的图片，WebP具有更小的文件体积。在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25% - 34%；WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。"
    },
    {
      "question": "如何用webpack来优化前端性能？",
      "answer": "用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。压缩代码：删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件，利用cssnano（css-loader?minimize）来压缩css。利用CDN加速：在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径。"
    },
    {
      "question": "什么是TreeShaking？",
      "answer": "将代码中永远不会⾛到的⽚段删除掉。"
    },
    {
      "question": "如何实现TreeShaking？",
      "answer": "可以通过在启动webpack时追加参数--optimize-minimize来实现。"
    },
    {
      "question": "什么是CodeSplitting？",
      "answer": "将代码按路由维度或者组件分块(chunk)，这样做到按需加载，同时可以充分利⽤浏览器缓存。"
    },
    {
      "question": "如何提取公共第三⽅库？",
      "answer": "使⽤SplitChunksPlugin插件来进⾏公共模块抽取，利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码。"
    },
    {
      "question": "Loader和Plugin在⽤法上有什么不同？",
      "answer": "Loader在module.rules中配置，也就是说他作为模块的解析规则⽽存在。类型为数组，每⼀项都是⼀个Object，⾥⾯描述了对于什么类型的⽂件（test），使⽤什么加载(loader)和使⽤的参数（options）。Plugin在plugins中单独配置。类型为数组，每⼀项是⼀个plugin的实例，参数都通过构造函数传⼊。"
    },
    {
      "question": "webpack的热更新又称为什么，缩写是什么？",
      "answer": "webpack的热更新⼜称热替换（HotModuleReplacement），缩写为HMR。"
    },
    {
      "question": "简述babel的转译过程。",
      "answer": "babel的转译过程分为三个阶段：解析Parse，将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；转换Transform，对于AST进⾏变换⼀系列的操作，babel接受得到AST并通过babel-traverse对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；⽣成Generate，将变换后的AST再转换为JS代码，使⽤到的模块是babel-generator。"
    },
    {
      "question": "简述gitpull和gitfetch的区别。",
      "answer": "gitfetch只是将远程仓库的变化下载下来，并没有和本地分支合并。gitpull会将远程仓库的变化下载下来，并和当前分支合并。"
    },
    {
      "question": "什么是XSS攻击？",
      "answer": "XSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等。XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合。"
    },
    {
      "question": "XSS攻击中攻击者可以进行哪些操作？",
      "answer": "获取页面的数据，如DOM、cookie、localStorage；DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；破坏页面结构；流量劫持（将链接指向某网站）"
    },
    {
      "question": "什么是存储型XSS？",
      "answer": "存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行"
    },
    {
      "question": "反射型XSS的攻击步骤是什么？",
      "answer": "1.攻击者构造出特殊的URL，其中包含恶意代码。2.用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器。3.用户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。4.恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作"
    },
    {
      "question": "DOM型XSS跟前两种XSS的区别是什么？",
      "answer": "DOM型XSS攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript⾃身的安全漏洞，⽽其他两种XSS都属于服务端的安全漏洞"
    },
    {
      "question": "CSRF攻击指的是什么？",
      "answer": "CSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作"
    },
    {
      "question": "当origin或者referer信息都不存在时，如何处理请求？",
      "answer": "直接阻止请求。"
    },
    {
      "question": "什么是跨站脚本（XSS）？",
      "answer": "⼀种代码注⼊⽅式,为了与CSS区分所以被称作XSS。早期常⻅于⽹络论坛,起因是⽹站没 有对⽤户的输⼊进⾏严格的限制,使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯,其注⼊⽅式很简单包括但不限于JavaScript/CSS/Flash等。"
    },
    {
      "question": "使用CSRFToken进行验证的操作步骤是什么？",
      "answer": "服务器向用户返回一个随机数Token，当网站再次发起请求时，在请求参数中加入服务器端返回的token，然后服务器对这个token进行验证。"
    },
    {
      "question": "网络劫持分为哪几种？",
      "answer": "网络劫持分为两种：（1）DNS劫持；（2）HTTP劫持。"
    },
    {
      "question": "浏览器渲染进程的线程有哪些？",
      "answer": "浏览器的渲染进程的线程总共有五种：（1）GUI渲染线程；（2）JS引擎线程；（3）时间触发线程 。"
    },
    {
      "question": "什么是孤儿进程？",
      "answer": "父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。"
    },
    {
      "question": "如何实现浏览器内多个标签页之间的通信？",
      "answer": "实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。通信方法如下：使用websocket协议，服务器可当做中介者，标签页向服务器发送数据，由服务器向其他标签页推送转发；使用ShareWorker的方式，共享线程充当中介者，标签页间通过共享线程实现数据交换；使用localStorage的方式，在一个标签页监听localStorage的变化事件，另一个标签页修改数据时通过该监听事件获取数据，localStorage对象充当中介者；使用postMessage方法，若能获得对应标签页的引用，就可以使用该方法进行通信。"
    },
    {
      "question": "浏览器缓存的全过程是怎样的？",
      "answer": "浏览器第一次加载资源，服务器返回200，浏览器从服务器下载资源文件，并缓存资源文件与responseheader。下一次加载资源时，先比较当前时间与上一次返回200时的时间差，若未超过cache-control设置的max-age，则命中强缓存，直接从本地读取资源；若浏览器不支持HTTP1.1，则使用expires头判断是否过期。若资源已过期，开始协商缓存，向服务器发送带有If-None-Match和If-Modified-Since的请求。服务器收到请求后，优先根据Etag的值判断文件有无修改，一致则命中协商缓存，返回304；不一致则返回新资源文件带上新Etag值并返回200。若服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200。"
    },
    {
      "question": "强缓存策略可以通过哪些方式设置？",
      "answer": "强缓存策略可以通过两种方式来设置，分别是http头信息中的Expires属性和Cache-Control属性。（1）服务器通过在响应头中添加Expires属性，来指定资源的过期时间。（2）在HTTP1.1中提出了Cache-Control属性，它提供了对资源的缓存的更精确的控制，其可设置的字段有public、private、no-cache、no-store、max-age=、s-maxage=、max-stale[=] 。"
    },
    {
      "question": "Cache-Control和Expires一起使用时，哪个优先级更高？",
      "answer": "Cache-Control的优先级要高于Expires。"
    },
    {
      "question": "no-cache和no-store的区别是什么？",
      "answer": "no-cache是指先要和服务器确认是否有资源更新，再进行判断，没有强缓存，但会有协商缓存；no-store是指不使用任何缓存，每次请求都直接从服务器获取资源。"
    },
    {
      "question": "协商缓存通过哪两种方式设置？",
      "answer": "协商缓存可以通过http头信息中的Etag和Last-Modified属性这两种方式来设置。"
    },
    {
      "question": "点击刷新按钮或者按F5、按Ctrl+F5（强制刷新）、地址栏回车有什么区别？",
      "answer": "点击刷新按钮或者按F5：浏览器直接对本地的缓存文件过期，但会带上If-Modifed-Since，If-None-Match，服务器会对文件检查新鲜度，返回结果可能是304，也有可能是200；用户按Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且不会带上If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是200；地址栏回车：浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。"
    },
    {
      "question": "Gecko内核有什么特点？",
      "answer": "Gecko是Firefox和Flock所采用的内核，优点是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，缺点是要消耗很多资源，比如内存。"
    },
    {
      "question": "Blink引擎是由谁共同研发的？",
      "answer": "Blink引擎现在是谷歌公司与Opera Software共同研发。"
    },
    {
      "question": "什么是事件？",
      "answer": "事件是用户操作网页时发生的交互动作，比如click/move，事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件是用户操作网页时发生的交互动作或者网页本身的一些操作。"
    },
    {
      "question": "简述浏览器渲染的步骤。",
      "answer": "首先解析收到的文档，根据文档定义构建一棵DOM树；然后对CSS进行解析，生成CSSOM规则树；根据DOM树和CSSOM规则树构建渲染树；生成渲染树以后，根据渲染树来进行布局（回流）；布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上。"
    },
    {
      "question": "前端储存方式有哪些？",
      "answer": "前端储存方式有：cookies、localStorage、sessionStorage、WebSQL、IndexedDB。cookies在HTML5标准前是本地储存主要方式；localStorage是HTML5加入的以键值对为标准的方式；sessionStorage与localStorage基本类似，但页面关闭后会被清理，是会话级储存方式；WebSQL是2010年被W3C废弃的本地数据库数据存储方案；IndexedDB是被正式纳入HTML5标准的数据库储存方案。"
    },
    {
      "question": "EventLoop的执行顺序是怎样的？",
      "answer": "首先执行同步代码，这属于宏任务；当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行；执行所有微任务；当执行完所有微任务后，如有必要会渲染页面；然后开始下一轮EventLoop，执行宏任务中的异步代码。"
    },
    {
      "question": "什么是幂等请求？GET和POST请求在幂等性上有什么区别？",
      "answer": "文中未明确给出幂等请求概念解释。GET请求是一个幂等的请求，一般用于对服务器资源不会产生影响的场景；而Post不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。"
    },
    {
      "question": "如果使用浏览器原生form表单且不设置enctype属性，数据会以什么方式提交？提交的数据放在哪里，格式是怎样的？",
      "answer": "会以application/x-www-form-urlencoded方式提交数据。该种方式提交的数据放在body里面，数据按照key1=val1&key2=val2的方式进行编码，key和val都进行了URL转码。"
    },
    {
      "question": "HTTP/2相对于HTTP/1.1在头信息处理上有哪些优化？",
      "answer": "HTTP/2实现了头信息压缩，一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。"
    },
    {
      "question": "HTTP和HTTPS协议的主要区别是什么？",
      "answer": "HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议。"
    },
    {
      "question": "HTTP协议和HTTPS协议的端口分别是多少？",
      "answer": "HTTP协议端口是80，HTTPS协议端口是443。"
    },
    {
      "question": "什么是HTTPS协议？",
      "answer": "超文本传输安全协议（HypertextTransferProtocolSecure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。"
    },
    {
      "question": "HTTP2的头部压缩算法是怎样的？",
      "answer": "HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。具体来说：在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。"
    },
    {
      "question": "HTTPS通信（握手）过程是什么？",
      "answer": "1.客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。2.服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。3.客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的hash的值，用来供服务器检验。4.服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的hash值来供客户端检验。5.客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。"
    },
    {
      "question": "DNS服务器解析域名的过程是什么？",
      "answer": "首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步；将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步；本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址；本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址；本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果；本地DNS服务器将返回结果保存在缓存中，便于下次使用；本地DNS服务器将返回结果返回给浏览器。"
    },
    {
      "question": "base64工作在OSI七层模型的哪一层？",
      "answer": "如果按功能来划分，base64应该是工作在表示层。"
    },
    {
      "question": "什么是对等通信？",
      "answer": "为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。"
    },
    {
      "question": "简述TCP三次握手的操作步骤。",
      "answer": "第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入SYN - SENT状态。第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入SYN - RECEIVED状态。第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接建立成功。"
    },
    {
      "question": "TCP四次挥手的第一次挥手过程是怎样的？",
      "answer": "客户端会发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务器的确认。"
    },
    {
      "question": "什么是HTML语义化？",
      "answer": "语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。"
    },
    {
      "question": "DOCTYPE的作用是什么？",
      "answer": "DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对CSS代码甚至JavaScript脚本的解析。它必须声明在HTML文档的第一行。"
    },
    {
      "question": "script标签中没有defer或async属性时，浏览器如何处理脚本？",
      "answer": "如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。"
    },
    {
      "question": "蓝色、红色、绿色分别代表什么？",
      "answer": "蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。"
    },
    {
      "question": "什么是空元素？",
      "answer": "空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签。"
    },
    {
      "question": "简述浏览器在线时对HTML5离线储存资源的管理和加载过程",
      "answer": "在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问页面，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。"
    },
    {
      "question": "SVG的特点有哪些？",
      "answer": "不依赖分辨率；支持事件处理器；最适合带有大型渲染区域的应用程序（比如谷歌地图）；复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快）；不适合游戏应用。"
    },
    {
      "question": "简述display的block、inline和inline-block的区别",
      "answer": "（1）block：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；（2）inline：元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；（3）inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。"
    },
    {
      "question": "CSSSprites在维护方面有什么麻烦之处？",
      "answer": "页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。"
    },
    {
      "question": "什么是CSS工程化？",
      "answer": "CSS工程化是为了解决以下问题：1.宏观设计：CSS代码如何组织、如何拆分、模块结构怎样设计？2.编码优化：怎样写出更好的CSS？3.构建：如何处理我的CSS，才能让它的打包结果最优？4.可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？"
    },
    {
      "question": "CSS优化在加载性能方面有哪些方法？",
      "answer": "（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用margin:top0bottom0；但margin-bottom:bottom;margin-left:left;执行效率会更高。（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。"
    },
    {
      "question": "在选择器性能优化方面，有哪些需要注意的点？",
      "answer": "（1）关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。（4）尽量少的去对标签进行选择，而是用class。（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。"
    },
    {
      "question": "预处理器普遍具备哪些特性？",
      "answer": "嵌套代码的能力，通过嵌套来反映不同css属性之间的层级关系；支持定义css变量；提供计算函数；允许对代码片段进行extend和mixin；支持循环语句的使用；支持将CSS文件模块化，实现复用。"
    },
    {
      "question": "什么是CSS像素和物理像素？",
      "answer": "CSS像素：为web开发者提供，在CSS中使用的一个抽象单位；物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。"
    },
    {
      "question": "如何用Webpack实现对CSS的处理？",
      "answer": "Webpack中操作CSS需要使用的两个关键的loader：css-loader和style-loader。css-loader：导入CSS模块，对CSS代码进行编译处理；style-loader：创建style标签，把CSS内容写入标签。在实际使用中，css-loader的执行顺序一定要安排在style-loader的前面。"
    },
    {
      "question": "em和rem的区别是什么？",
      "answer": "em和rem都是相对长度单位，它们之间的区别：em相对于父元素，rem相对于根元素。em：相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。rem：相对于根元素（html元素）的font-size的倍数。"
    },
    {
      "question": "利用绝对定位实现水平垂直居中，有哪几种方法及适用情况？",
      "answer": "1. 先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要考虑浏览器兼容问题。2. 设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于盒子有宽高的情况。3. 先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于盒子宽高已知的情况。"
    },
    {
      "question": "什么是BFC？",
      "answer": "可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。"
    },
    {
      "question": "创建BFC的条件有哪些？",
      "answer": "根元素：body；元素设置浮动：float除none以外的值；元素设置绝对定位：position(absolute、fixed)；display值为：inline-block、table-cell、table-caption、flex等；overflow值为：hidden、auto、scroll。"
    },
    {
      "question": "如何解决1px问题（思路二伪元素先放大后缩小的操作步骤）？",
      "answer": "在目标元素的后面追加一个::after伪元素，让这个元素布局为absolute之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为1px。接着借助CSS动画特效中的放缩能力，把整个伪元素缩小为原来的50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而border也缩小为了1px的二分之一，间接地实现了0.5px的效果。"
    }
  ]
}